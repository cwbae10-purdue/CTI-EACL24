Recently, Adobe patched some security vulnerabilities in Adobe Acrobat and Reader.
One of them is a use-after-free vulnerability (CVE-2016-4119) discovered by Fortinet's FortiGuard Labs.
In this blog, we want to share our analysis of this vulnerability.
This vulnerability can be reproduced by opening the PDF file “PoC_decrypt.pdf” with Adobe Reader DC.
When opened, AcroRd32.exe crashes, and the crash information shows the following:
(28d8.110): Access violation - code c0000005 (first chance) First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=26ace5e0 ebx=07887004 ecx=25b71fd8 edx=00000001 esi=1cc81d14 edi=26bcd81c eip=6021d2e1 esp=26ace5cc ebp=26ace5ec iopl=0 nv up ei pl nz na pe nc cs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00010206 AcroRd32_60000000!CTJPEGDecoderReadNextTile+0x24661: 6021d2e1 8b01 mov eax,dword ptr [ecx] ds:002b:25b71fd8=????????
1:027> kb ChildEBP RetAddr Args to Child WARNING: Stack unwind information not available.
Following frames may be wrong.
26ace5ec 6021d2a3 1ca54428 26ace624 6056bd31 AcroRd32_60000000!CTJPEGDecoderReadNextTile+0x24661 26ace5f8 6056bd31 00000001 e3163325 26bcd81c AcroRd32_60000000!CTJPEGDecoderReadNextTile+0x24623 26ace624 6056bf9f 1ca544e8 26ace63c 601253d0 AcroRd32_60000000!AX_PDXlateToHostEx+0x1f4efa 26ace630 601253d0 00000001 26ace668 0799e13b AcroRd32_60000000!AX_PDXlateToHostEx+0x1f5168 26ace63c 0799e13b 1ca54428 e317e5fe 26bcd81c AcroRd32_60000000!CTJPEGWriter::CTJPEGWriter+0x7be7f 26ace668 0799e0ff 0788484c 1ca544e8 26bcd81c AGM!AGMInitialize+0x658df 26ace694 07885410 00000001 26ace70c 07948e77 AGM!AGMInitialize+0x658a3 26ace6a0 07948e77 26bcd81c 0cff3ba8 0797701a BIB!BIBInitialize4+0x3cd2 26ace70c 07885410 00000001 26acef84 07948e77 AGM!AGMInitialize+0x1061b 26ace718 07948e77 26bcdc18 00000004 07f697f2 BIB!BIBInitialize4+0x3cd2 26acefd8 0798d491 26acf07c 26acf05c 00000009 AGM!AGMInitialize+0x1061b 26acf024 07a378c0 1ca62834 00000000 26acf05c AGM!AGMInitialize+0x54c35 26acf060 07968be6 26acf1e8 26acf1b0 00000000 AGM!AGMGetVersion+0x77cbc 26acf0c4 07882479 0789a000 26acf5a8 26acf5c8 AGM!AGMInitialize+0x3038a 26acf0dc 07886bf0 e317f2d0 0789a000 0cff38b4 BIB!BIBInitialize4+0xd3b 26acf654 07f699bf 07f69a50 26acf86c 26acfe4c BIB!BIBGetGetProcAddress+0x1163 26acf76c 07c6c87b 00000000 0798ab66 07988f41 MSVCR120!CallCatchBlock+0x140 [f:\dd\vctools\crt\crtw32\eh\frame.cpp @ 1455] 26acf8e0 07961ba4 00000000 16020760 07961b79 AGM!AGMGetVersion+0x2acc77 26acf8ec 07961b79 00000000 0795ea3b 26acf944 AGM!AGMInitialize+0x29348 26acf8f4 0795ea3b 26acf944 e317fa92 00000000 AGM!AGMInitialize+0x2931d 00000000 00000000 00000000 00000000 00000000 AGM!AGMInitialize+0x261df 1:027> !heap -p -a ecx address 25b71fd8 found in _DPH_HEAP_ROOT @ 2e21000 in free-ed allocation ( DPH_HEAP_BLOCK: VirtAddr VirtSize) 259c17b8: 25b71000 2000 112490b2 verifier!AVrfDebugPageHeapFree+0x000000c2 7df4251c ntdll!RtlDebugFreeHeap+0x0000002f 7defb2a2 ntdll!RtlpFreeHeap+0x0000005d 7dea2ce5 ntdll!RtlFreeHeap+0x00000142 7dd714bd kernel32!HeapFree+0x00000014 07f5ecfa MSVCR120!free+0x0000001a 601fe7e8 AcroRd32_60000000!CTJPEGDecoderReadNextTile+0x00005b68 6056e29b AcroRd32_60000000!AX_PDXlateToHostEx+0x001f7464 601ec89f AcroRd32_60000000!CTJPEGWriter::CTJPEGWriter+0x0014334e 0798d5ff AGM!AGMInitialize+0x00054da3 1:027> u AcroRd32_60000000!CTJPEGDecoderReadNextTile+0x24661: 6021d2e1 8b01 mov eax,dword ptr [ecx] 6021d2e3 52 push edx 6021d2e4 ff10 call dword ptr [eax] 6021d2e6 83a6c800000000 and dword ptr [esi+0C8h],0 6021d2ed 8b8618010000 mov eax,dword ptr [esi+118h] 6021d2f3 85c0 test eax,eax 6021d2f5 742a je AcroRd32_60000000!CTJPEGDecoderReadNextTile+0x246a1 (6021)
6021d2f7 50 push eax
This vulnerability exists in Adobe Reader DC because it fails to parse the PDF file correctly.
It’s a use-after-free vulnerability based on the debug information in the previous section.
Let’s look into this specially crafted PDF file first.
The comparison between the normal PDF file and the minimized PoC file is shown below.
Figure 1.
The PoC File vs The Original PDF File
Figure 2.
The Parsing of the PoC File with 010 Editor
In Figure 1 and Figure 2, the only difference is a single byte at offset 0x25B0C between the original PDF file and PoC file, and this byte is located in obj 29 in the PDF file.
The object structure is shown below.
This object stores an image with width 405(0x195) and height 134(0x86).
The data in it has been compressed using the deflate algorithm.
(For more information on deflate, please refer to https://tools.ietf.org/html/rfc1951.)
Zlib is a C library which implements the deflate algorithm.
We can use a python script to decompress the data in obj 29.
When the script is run, we can see the following exception.
This means that some error occurs while decompressing the data.
Only part of the data is successfully decompressed.
The decompressed data is shown below and its length is 0x54FC.
Figure 3.
Part of Decompressed Data
By reversing Adobe Reader DC, we can see that it also uses zlib to decompress the deflate-compressed data.
So next, let’s look at the crash information.
From the above debug information, we can see that ECX points to an invalid memory address which is gotten from ESI+C8.
ESI (address is 0x1cc81d14) is located in a heap buffer, with size 0xfe0c.
So we need to figure out how the heap buffer is created, and how the data in it is handled.
Following is the code snippet around the address 0x07881f2d.
Let’s set the following breakpoint in Windbg.
From the following debug information, we can see this breakpoint is hit several times.
The next question, then, is how to find the heap buffer that causes the access violation.
In Figure 3, we can see some ASCII characters in the decompressed data.
We can search for them in memory and the results are shown below:
There are three memory buffers that include the string.
The debug information is shown below:
The above memory information matches the decompressed data in Figure 3.
After repeating the debug, we found the memory address 0x1a1e7619 located in the heap buffer causes the access violation.
The heap buffer starts at address 0x1a1e21f0, and its size is 0xfe0c.
It contains the decompressed data whose size is 0x54fc.
Next, we need to trace the heap buffer that starts at address 0x1a1e21f0.
We can set the following breakpoint in Windbg:
Continue to run until breakpoint 13 is hit on the 4th time.
Following is the debug information:
When we continue to run, we get the following debug information:
Following is the ‘if’ branch in function sub_6056dc50.
Because [ebp+var_8C] is equal to 0, it will take the green color branch.
In this branch, the pointer of the heap buffer isn’t set to NULL after the heap buffer is freed.
So this is what causes the use-after-free issue.
Figure 4.
‘If’ Branch in Function sub_6056dc50
Let’s set the following breakpoint to trace why [ebp-8c] is equal to zero:
Continue to run:
Following is the C code of function sub_601F6EE9:
Next, enter the function sub_60107100.
Then enter the function sub_60061927:
Then enter the function sub_60061948:
From the above analysis, we know why [ebp-8c] is equal to 0.
Next, let’s set the following breakpoint to take the “if” branch we saw in Figure 4.
Continue to run.
We can see the following debug information:
Because [ebp-8c] is equal to 0, the program takes the green color branch.
If it takes the red color branch, the heap buffer pointed by [this+0x38]+0xC8 will be freed and set [[this+0x38]+0xC8] to NULL.
Figure 5.
Red Color Branch 1
Figure 6.
Red Color Branch 2
Take the green color branch as follows.
Figure 7.
Green Color Branch
Set the following breakpoint to check when the heap buffer 0x1940dfd8 and 0x1b8f4fd8 are freed:
bu AcroRd32_60000000!CTJPEGDecoderReadNextTile+0x5b62
Continue to run.
We can now see that the heap buffer 0x1940dfd8 has been freed.
Continue to run.
We can see the data at address 0x1a1f0d34 is set to 0x1bc7afd8 and the heap buffer 0x1b8f4fd8 has been freed.
Continue to run.
We can see the heap buffer 0x1bc7afd8 has been freed and the data at address 0x1a1f0d34 is set to NULL.
Continue to run.
This is where the crash occurs.
Based on the above analysis, we can finally draw a picture to explain how the heap buffer is created, freed, and then reused.
Figure 8.
How the Heap Buffer is Created, Freed, then Reused
In short, because Adobe Reader DC fails to decompress the deflate-compressed data, it gets incomplete image data.
Then, when it handles the data, a use-after-free issue is triggered.
Use-after-free vulnerabilities are often very complex and their causes vary from case to case.
The common scenario works like this:
At some point an object is created with a vtable,
Later, the object gets called by a vtable pointer.
If the object is freed before it gets called, the program will crash when it tries to call the object.
To exploit this kind of vulnerability, you normally need to perform the following steps:
At some point an object is created with a vtable,
Trigger a free operation on this object,
Create a fake object which resembles the freed object as closely as possible,
Later, when the vtable pointer is called, the fake object will be accessed and gain code execution.
All users of Adobe Acrobat and Reader are encouraged to upgrade to the latest version of this software.
