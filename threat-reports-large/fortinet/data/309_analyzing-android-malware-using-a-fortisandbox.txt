In this blog post we will analyze a couple of Android malware samples in the Android VM of the FortiSandbox.
We'll also share a few interesting and useful tricks.
To run a given sample in the Android VM, you should log into the FortiSandbox, make sure an Android VM is available, and then "Scan Input" / Submit a New File.
Figure 1: File On Demand
Next, if the objective is to run the malware in the sandbox, you must make sure to skip "static scan," "AV scan," and "Cloud Query" or they are likely to detect your malicious sample even before it reaches the sandbox.
Figure 2: Skipping AV Scan
Samples analyzed:
The sandbox outputs a tracer package which contains valuable information for analysis.
In particular, the tracer.log file keeps track of process creation, events, and function calls and what they return.
It is lengthy to read, but very precise.
I/FTNT: tag for the Fortinet tracer.
1138: process PID
Call / Return: Call means we are calling a given method.
Return means it is returning.
A -> B = C: this means that method A calls method B.
The precise call to B, with its argument values, is shown in statement C. If this is a return, C shows what is returned.
For example, the Android/SpyBanker malware opens a socket with hxxp://193.201.224.22:3000
Later, you will see a connection error on this socket (because the remote C&C no longer responds, of course):
As you may know, Android/SpyBanker spies on incoming SMS messages.
Fortunately, this malicious behaviour is shown by the sandbox, which sends a few test SMS messages to the Android VM.
For example, the traces below show the malware processing an incoming SMS.
We see the malware's function getMessage() gets called.
It retrieves the SMS from the incoming PDU (first line), reads the originating phone number (second line), which is "+12345678" (third line).
It then retrieves the message body (fourth line), which is "ping" (fifth line).
This feature is very useful because it makes it possible to list all the files the malware uses (creates, reads, or writes).
The trick is to search the trace logs for any call to sys_open and then read the file name.
This bash snippet does wonders:
This outputs several files, many of which correspond to the Android VM.
For example, these are the relevant files for Android/Sandr.C:
/data/app/net.droidjack.server-1.apk
/data/dalvik-cache/data@app@net.droidjack.server-1.apk@classes.dex
/data/data/net.droidjack.server/databases
/data/data/net.droidjack.server/databases/SandroRat_Configuration_Database
/data/data/net.droidjack.server/databases/SandroRat_Configuration_Database-journal
/data/data/net.droidjack.server/databases/SandroRat_CrashReport_Database
/data/data/net.droidjack.server/databases/SandroRat_CrashReport_Database-journal
We can list all strings used by a malware with an adequate grep in the traces.
Good news!
This works for any string the malware constructs, i.e also for decrypted strings.
For instance, Android/Obad.A!tr implements string obfuscation.
In string obfuscated classes, there is an obfuscated static string table at the beginning of the class, and later a home-made decryption function named cOIcOOo.
The decryption function decrypts part of the string table.
It takes three integers as parameters.
One of these parameters resolves to the offset in the string table to start decrypting, and another resolves to the length to decrypt.
The inner implementation of the decryption function is slightly different for each class, so that a single decryption function cannot decrypt all strings.
One way to decrypt the strings is to write a decryptor for each string obfuscated class, or a disassembler plugin.
This works but takes some time to implement.
A quicker solution consists in using the traces of the sandbox and reading the outputs for return calls to cOIcOOo.
For example, in the sample below one string decrypts to "AES/CBC/PKCS5Padding":
For a nicer output, we can grep through the traces to decrypt all strings that way:
We get numerous decrypted strings such as:
Traces are also useful to work around reflection obfuscation tricks.
For example, the following calls (from Android/Obad) the connect() method of java.net.HttpURLConnection.
Hope you enjoyed the tricks!
Thanks to Alain Forcioli who helped for this research.
