I’ve recently investigated malware that we received from a customer.
The SHA-256 is: f4d9660502220c22e367e084c7f5647c21ad4821d8c41ce68e1ac89975175051.
This is not particularly complex malware from a technical point of view, but it illustrates some of the most common techniques used by malware authors to complicate dynamic (automated) and static (manual) analysis.
In order to detect the dynamic analysis environment, it creates a vector that contains a list of the following programs:
“OLLYDBG”
“W32DASM”
“WIRESHARK”
“SOFTICE”
“PROCESS EXPLORER”
“PROCESS MONITOR”
“PROCESS HACKER”
The malware enumerates all windows on the infected system, and if any of them are found to belong to one of the programs listed above, the malware would enter a loop and wait for the program to exit.
This is a primitive technique, but it is fairly easy and straightforward to implement in a code.
To complicate the static analysis, the malware implements two additional techniques:
1.
Any significant strings in the malware are encrypted using a custom encryption scheme.
This has the following implications for the malware authors and analysts:
Command-and-control (C&C) domain(s) can be hard-coded in the malware.
There is no need for malware authors to generate domain generation algorithms (DGA).
Those DGAs can be good candidates for the signatures, and malware authors in some cases can incur significant “maintenance” costs for constantly changing DGAs.
Application programming interfaces (APIs) used by the malware are resolved at runtime; the names of those APIs are decrypted at runtime, as well.
This means that static analysis becomes meaningful only after analyst is able to understand the encryption scheme.
2.
Communications to the C&C is encrypted using a custom scheme:
Malware communicates to the C&C using custom-encrypted/obfuscated communication on top of regular HTTP.
This allows malware authors to generate a fairly generic module that provides a low-cost solution for changing the communication scheme between the infected clients and the C&C.
Additionally, real-time network analysis/monitoring can be rendered partially/totally ineffective.
Now let’s take a deeper look at the strings encryption scheme.
For example, let’s look at the following string: “UHEOtTKwmsDb1J/2f8l/5w==”.
This seems to be the base64 encoded string, but encryption scheme is slightly more complicated.
As a first step, the malware generates a key from the hard-coded data.
The key generation steps are as shown below:
Hard-coded string is taken: (1)
The (1) is then base64 encoded: (2)
Then, MD5 hash of (2), then calculated: (3)
Next, the malware calculates an MD5 hash of the following hard-coded blob of data: (4)
The MD5 hash is: (5)
(3) and (5) are concatenated: (6)
The MD5 hash of (6) is calculated, and this becomes the key for Tiny Encryption Algorithm (TEA) encryption: (7)
At this point, preparation is finished and the malware is ready to decrypt strings.
The decryption algorithm is as follow:
1.
Take the encrypted string — for example, “UHEOtTKwmsDb1J/2f8l/5w==” — and apply a base64-like function to it.
2.
Use TEA on the result of 1.
The key is produced in (7).
3.
Simple final loop to get the decrypted string:
4.
The decrypted string is:
The payload consists of the data gathered about the system and is separated by hard-coded strings from the “.data” section.
This is a pretty standard scheme used by the malware.
The payload generation scheme is described below:
Creates a pseudorandom string and concatenates is with “&” —for example, on the test system: (8)
Adds hostname name and PID: (9)
Creates additional pseudorandom string and concatenates it with hard-coded values: (10)
(8), (9) and (10) are concatenated: (11)
Hard-coded data is added to (11): (12)
An MD5 hash of the string in (5) is calculated, and a sub-string of it is taken: (13)
(13) is appended to (12):
Information about the major/minor operating system versions and build is added to the payload: (14)
Locale information is added to (14): (15)
Global memory information and system-time information is added to (15): (16)
This data in (16) is then encoded using the following algorithm — “Dm1cL,” a randomly generated key for xor — and is HTML-escaped:
The xor’ed and escaped data is: (17)
Firstly, variations of the same techniques described above can be found in many modern malware families.
This allows malware authors to hit three targets with one shot.
It is a pretty simple encryption scheme, and provided decent design on the part of malware authors, it allows them to change it relatively efficiently.
Secondly, it can slightly complicate dynamic and static analysis.
Thirdly, it provides an efficient tool for creation of new variants of the same malware that is able to bypass antivirus signatures.
A collection with the relevant malware file hash, malicious domains and IP addresses is available on X-Force Exchange here.
Additionally, the list of hard-coded C&C domains found in the malware is provided below:
“76TtKl8ZwW6MU29wmPDtT1QNcj5UDbqn/KIVj42N4ZYkZEPTS6ByTw==” / “hxxp://www.n-fit-sub.com/ec/index.php”
_______________________________________________________________________________
Igor Aronov is a member of the IBM X-Force Advanced Research Team.
