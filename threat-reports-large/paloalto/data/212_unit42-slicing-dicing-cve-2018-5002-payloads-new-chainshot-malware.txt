This story begins with one of our blog authors, who, following the discovery of a new Adobe Flash 0-day, found several documents using the same exploit that were used in targeted attacks.
We were also able to collect network captures including the encrypted malware payload.
Armed with these initial weaponized documents, we uncovered additional attacker network infrastructure, were able to crack the 512-bit RSA keys, and decrypt the exploit and malware payloads.
We have dubbed the malware ‘CHAINSHOT’, because it is a targeted attack with several stages and every stage depends on the input of the previous one.
This blog describes the process we took to analyze the malware, how we managed to decrypt the payloads, and then how we found parts of a new attack framework.
We also found additional network infrastructure which indicates similar attacks were conducted against a wide range of targets with disparate interests.
This attack chain is designed in a way that makes it very difficult to execute a single part on its own, be it the exploit or payload.
To make our analysis easier, we reproduced the server-side infrastructure, by doing so we were able to conduct dynamic analysis and get a better understanding how the exploit and payload work together.
This serves as a follow-up of Icebrg’s article which describes the initial findings.
Cracking a RSA Key
First, let’s recap how the overall attack chain works to understand at which point the RSA key is needed.
The malicious Microsoft Excel document contains a tiny Shockwave Flash ActiveX object with the following properties:
Figure 1.
Malicious Shockwave Flash ActiveX object properties
The “Movie” property contains a URL to a Flash application which is downloaded in cleartext and then executed.
The “FlashVars” property contains a long string with 4 URLs which are passed to the downloaded Flash application.
The Flash application is an obfuscated downloader which creates a random 512-bit RSA key pair in memory of the process.
While the private key remains only in memory, the public keys’ modulus n is sent to the attacker’s server.
On the server side, the modulus is used together with the hardcoded exponent e 0x10001 to encrypt the 128-bit AES key which was used previously to encrypt the exploit and shellcode payload.
The encrypted exploit or payload is sent back to the downloader which uses the in-memory private key to decrypt the AES key and the exploit or payload.
As the modulus is sent to the server of the attacker, it’s also in our network capture.
Together with the hardcoded exponent we have the public key which we can use to get the private key.
Keep in mind that this was only possible because the attacker chose a key length of 512-bit which is known to be insecure.
In order to do so, we have to factorize the modulus n into its two prime numbers p and q. Luckily this problem has already been solved previously, by an awesome public project ‘Factoring as a Service‘.
The project uses Amazon EC2’s high computing power and can factorize large integers in just a matter of hours.
Following this logic, let’s take the following modulus of the public key sent to the attacker’s server to get the shellcode payload.
Figure 2.
HTTP POST request for the encrypted shellcode payload with the modulus n in hexadecimal
After removing the first 2 bytes which are used in this case to retrieve the 32-bit version of the shellcode payload, we have the following modulus in hexadecimal:
After we have factorized the integer, we get the following two prime numbers in decimal:
P
Q
With the help of p and q we can calculate the private key.
We used a small public tool to create it in Privacy Enhanced Mail (PEM) format:
With the help of the private key we could now decrypt the 128-bit AES key.
We used OpenSSL to do this:
The encrypted AES key is extracted from the encrypted binary blob as described by Icebrg.
It’s at offset 0x4 and has the length of 0x40 bytes.
Encrypted AES key:
Decrypted AES key:
Now that we have the decrypted AES key, we can decrypt the actual payload.
The Flash downloader uses a custom initialization vector (IV) for the AES algorithm which can be found at offset 0x44 in the encrypted blob and is 16 bytes long:
For the final decryption we used OpenSSL again:
The decrypted shellcode payload is additionally compressed with zlib which can be seen by looking at the first 2 magic bytes 0x789C.
We decompressed it with Offzip.
Finally, we have the decrypted shellcode payload.
The same procedure can be used to decrypt the Flash exploit which isn’t additionally zlib compressed.
Server-side Reproduction
After we had the decrypted Flash exploit and shellcode payloads, we started to do a static analysis which turned out to be a quite tedious task.
This is due to the obfuscation in the exploit and the complexity of shellcode payload which contains its own two PE payloads.
Next, we attempted to do a dynamic analysis which quickly turned out to be impossible, because every stage relies on data passed from the previous.
The shellcode payload does not execute properly without the data passed to it from the exploit.
The exploit does not execute on its own without the variables passed from the downloader and so on.
Due to the difficulties of analyzing the code statically, we decided to reproduce a simplified version of the server-side PHP scripts in order to make a full dynamic analysis possible.
As we had the decrypted exploit, shellcode payload and the PCAP, we had all the information required to do so.
Specifically, we created the following setup:
Local Apache server with XAMPP, with the domain used in the attack configured to resolve to localhost
A directory structure which mirrored that on the attackers’ servers (as specified in the PCAPs)
Setting of custom HTTP headers as per the PCAPs’ responses.
All of the requested files are sent back gzip encoded, otherwise the attack chain doesn’t work.
We have uploaded the PHP scripts to our GitHub account, so you can also play with the different stages and see how it works.
Additional Details of the Flash Exploit
While the exploit has been already described, we want to give some additional details surrounding it that we found during our analysis.
In particular, we were interested in the part which transfers execution to the shellcode payload.
While most parts of the decompiled ActionScript exploit code are obfuscated, luckily some method names were left in cleartext.
Because the decrypted shellcode payload doesn’t run on its own when transformed into an executable, we have to figure out how execution works and if one or more parameters are passed.
Therefore, the most interesting method for us is “executeShellcodeWithCfg32” which indicates we can find the passed data in it.
It creates a small shellcode template and fills some placeholder values at runtime.
The disassembled template looks as follows:
Figure 3.
Shellcode template with placeholders (red) in the Flash exploit to pass execution to the shellcode payload
While the final prepared shellcode looks as follows:
Figure 4.
Runtime version of the shellcode template with filled placeholders
Let’s take a look at what values are set to the placeholders (0x11111111, 0x22222222, …).
The address 0xA543000 in Figure 4 is the entrypoint of the decrypted shellcode payload which has a small NOP sled in front of the actual code:
Figure 5.
Entrypoint of the shellcode template in memory
The address 0x771A1239 in Figure 4 is in the middle of the function NtPrivilegedServiceAuditAlarm in ntdll.dll:
Figure 6.
Windows API function NtPrivilegedServiceAuditAlarm
However, we can also see in Figure 4 that before calling the API function via “call edx”, the value 0x4D is moved into eax which is the ID of the API function NtProtectVirtualMemory.
By doing so, the function NtProtectVirtualMemory is executed without calling it directly.
This trick is likely used to bypass AVs/sandboxes/anti-exploit software which hook NtProtectVirtualMemory and the attacker probably chose NtPrivilegedServiceAuditAlarm as a trampoline as it’s unlikely to be ever be monitored.
The data at this address 0x9DD200C in Figure 4 looks like a structure into which the last NTSTATUS return value of NtProtectVirtualMemory is copied.
The address of this structure seems to be passed to the shellcode payload in ebx, however we haven’t figured out what’s its purpose is.
Finally, shellcode payload is executed via “call edi”
To sum up, the memory access rights of the shellcode payload are changed in 0x1000 byte blocks to RWE via NtProtectVirtualMemory.
The last NTSTATUS code is saved into memory pointed to by ebx and the shellcode payload is executed.
Another interesting aspect of the exploit code is that it sends status messages when something goes wrong at every stage of the exploitation.
These status messages are very similar to those send by the initial Flash downloader and are sent to the attacker’s server via fake PNG files (see Icebrg).
They also contain the “/stab/” directory in the URL and the actual message is also sent encoded via custom digit combinations.
However, the status message of the exploitation code contains additional information in the form of abbreviations of the appropriate stage.
By looking at those messages, we can get a better understanding how the exploit works.
The following messages are possible:
