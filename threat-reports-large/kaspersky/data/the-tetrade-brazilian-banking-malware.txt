Brazil is a well-known country with plenty of banking trojans developed by local crooks.
The Brazilian criminal underground is home to some of the world’s busiest and most creative perpetrators of cybercrime.
Like their counterparts’ in China and Russia, their cyberattacks have a strong local flavor, and for a long time, they limited their attacks to the customers of local banks.
But the time has come when they aggressively expand their attacks and operations abroad, targeting other countries and banks.
The Tetrade is our designation for four large banking trojan families created, developed and spread by Brazilian crooks, but now on a global level.
Although this is not their first attempt – they tried, timidly, in 2011, using very basic trojans, with a low success rate – now the situation is completely different.
Brazilian banking trojans have evolved greatly, with hackers adopting techniques for bypassing detection, creating highly modular and obfuscated malware, and using a very complex execution flow, which makes analysis a painful, tricky process.
At least since the year 2000, Brazilian banks have operated in a very hostile online environment full of fraud.
Despite their early adoption of technologies aimed at protecting the customer, and deployment of plugins, tokens, e-tokens, two-factor authentication, CHIP and PIN credit cards, and other ways to safeguard their millions of clients, fraud is still ramping up, as the country still lacks proper legislation for punishing cybercriminals.
This article is a deep dive intended for a complete understanding of these four banking trojan families: Guildma, Javali, Melcoz and Grandoreiro, as they expand abroad, targeting users not just in Brazil, but in the wider Latin America and Europe.
These crooks are prepared to take on the world.
Are the financial system and security analysts ready to deal with this persistent avalanche?
The Guildma malware has been active since at least 2015, when it was targeting banking users exclusively from Brazil.
From there on, it has been constantly updated, adding new targets, new features and stealthiness to its campaigns, and directing its attacks at other countries in Latin America.
The group behind the attacks have shown a good knowledge of legitimate tools for performing a complex execution flow, pretending to hide themselves inside the host system and preventing automated analysis systems from tracking their activities.
Recently, a newer version was found in-the-wild, abusing NTFS Alternate Data Streams (ADS) in order to store the content of malicious payloads downloaded during execution.
The malware is highly modular, with a very complex execution flow.
The main vector used by the group is sending malicious files in compressed format, attached to email.
File types vary from VBS to LNK; the most recent campaign started to attach an HTML file which executes Javascript for downloading a malicious file.
The malware relies on anti-debugging, anti-virtualization and anti-emulation tricks, besides the usage of process hollowing, living-off-the-land binaries (LOLBin) and NTFS Alternate Data Streams to store downloaded payloads that come from cloud hosting services such as CloudFlare’s Workers, Amazon AWS and also popular websites like YouTube and Facebook, where they store C2 information.
Guildma spreads rely heavily on email shots containing a malicious file in compressed format, attached to the email body.
File types vary from Visual Basic Script to LNK.
Most of the phishing messages emulate business requests, packages sent over courier services or any other regular corporate subjects, including the COVID-19 pandemic, but always with a corporate appearance.
Purchase invoice for alcohol gel: Guildma’s trick for luring victims
We observed that in the beginning of November 2019, another layer was added to the infection chain.
Instead of attaching a compacted file directly to the email body, the attackers were attaching an HTML file which executed a Javascript for downloading the file.
Javascript executed in order to download a compressed LNK file
In order to download the additional modules, the malware uses the BITSAdmin tool, which this group has relied on for some years to avoid detection, since this is an allowlisted tool from the Windows operating system.
By the end of September 2019, we started seeing a new version of Guildma malware being distributed that used a new technique for storing downloaded payloads in NTFS Alternate Data Streams in order to conceal their presence in the system.
Downloaded payload being stored in desktop.ini’s ADS
The usage of ADS helps to hide the file in the system, since it will not appear in Explorer, etc.
In order to see the alternate data, you can use the “DIR” command, adding the switch “/R”, which is specifically intended for to displaying alternate data streams.
Payloads stored in the ADS data of desktop.ini
After the additional modules are hidden, the malware will launch itself by using DLL Search Order Hijacking.
We have observed various processes being used by Guildma at this step; in this version of the malware, it uses ExtExport.exe, which is related to Internet Explorer.
The library that will be loaded is the result of concatenating two files (<random>64a.dll and <random>64b.dll), downloaded previously, as we can see in the image above.
The resultant file will be named with different known libraries that are loaded by ExtExport on its execution.
Once loaded, it will concatenate three other files and also load them.
Some of the anti-debugging/anti-emulation techniques used by the loader
This stage checks for debugging tools, virtual environments, known Windows product IDs commonly used by sandboxes, common usernames and certain disk serial numbers that are most likely associated with analyst environments detected earlier.
If nothing like that is detected, the malware will decrypt the third stage and execute it by using the process hollowing technique, commonly used by malware authors.
In this version, the payloads are encrypted with the same XOR-based algorithm as the one used in previous versions, however in this latest version, the payload is encrypted twice, with different keys.
File content is encrypted twice using different keys
In order to execute the additional modules, the malware uses the process hollowing technique for hiding the malicious payload inside an allowlisted process, such as svchost.exe.
The payloads are stored encrypted in the filesystem and decrypted in the memory as they are executed.
The final payload installed in the system will monitor user activities, such as opened websites and run applications and check if they are on the target list.
When a target is detected, the module is executed, giving the criminals control over banking transactions.
This module allows the criminals to perform certain very specific banking operations, such as:
full control over page navigation through the use of a VNC-like system,
toggling screen overlay,
requesting SMS tokens,
QR code validation,
requesting transaction
The attacker can essentially perform any financial transactions by using the victim’s computer, while avoiding anti-fraud systems that can detect banking transactions initiated by suspicious machines.
After all loading steps, the malware will run in the infected system.
It will monitor the system, communicating with the C2 server and loading additional modules as requested.
In the latest versions, it started to store C2 information in encrypted format on YouTube and Facebook pages.
C2 information hosted on a YouTube page
The newer versions of Guildma found in 2020 are using an automated process to generate thousands of daily URLs, mostly abusing generic TLDs.
Our systems have been catching more than 200 different URLs per day, such as:
Some of Guildma’s URLs for downloading malware
Our telemetry shows detections of Guildma are widespread.
Guildma: widespread globally
The intended targets of Guildma can be seen in the code: the malware is capable of stealing data from bank customers living in Chile, Uruguay, Peru, Ecuador, Colombia, China, Europe, and of course, Brazil.
However, the code has been found in just one version of Guildma and has not been implemented in any of the newer versions.
From Guildma’s code: possible target countries
Javali targets Portuguese- and Spanish-speaking countries, active since November 2017 and primarily focusing on the customers of financial institutions located in Brazil and Mexico.
Javali uses multistage malware and distributes its initial payload via phishing emails, as an attachment or link to a website.
These emails include an MSI (Microsoft Installer) file with an embedded Visual Basic Script that downloads the final malicious payload from a remote C2; it also uses DLL sideloading and several layers of obfuscation to hide its malicious activities from analysts and security solutions.
The initial Microsoft Installer downloader contains an embedded custom action that triggers a Visual Basic Script.
The script connects to a remote server and retrieves the second stage of the malware.
Using MSI’s ‘CustomAction’ events to trigger the execution of the downloader VBS
The downloaded ZIP file package contains several files and a malicious payload that is capable of stealing financial information from the victim.
A decompressed package commonly contains a large number of files including executables that are legit but vulnerable to DLL sideloading.
The contents of a typical Javali .ZIP package, including a 602 MB DLL file
The legitimate DLL that would be used in this case has the size of roughly 600 KB, but here we have an obfuscated library that is over 600 MB.
The large size of the file is intended to hamper analysis and detection.
In addition to that, file size limitations will prevent uploading to multiscanners like VirusTotal, etc.
Once all empty sections have been removed from the library, the final payload is a binary of 27.5 MB…
After deobfuscating it all, we are able to see the URLs and the names of banks targeted by the malware.
Javali after deobfuscation: looking for Mexican bank customers
Once the library is called by one of the triggering events implemented in its code, it reads a configuration file from a shared Google Document.
If it is not able to connect to the address, it uses a hardcoded one.
Configuration settings stored in a shared Google Document
The original configuration.
