Exploits
Dropper
Loader Module
Main component
Modules, general overview
Recon group
Password group
Email group
USB drive group
Keyboard group
Persistence group
Spreading group
Mobile group
Exfiltration group
Known locations: %APPDATA%MicrosoftRtkN32Gdi.exe
The module is created and executed (for the first time) by the module “fileputexec”.
Known variants:
The file is a PE EXE file, compiled with Microsoft Visual Studio 2010.
Creates encrypted log files: “%TMP%smrdprevsmrdprev_%p_%p.tmp”, where “%p” parameters are formatted from the return values of subsequent GetTickCount API calls.
Creates event: “Globalwsheledstpknt”
Creates mutex: “NtWinWMIctlshed”
When started, the module initializes its log object with a new filename.
Then, it creates one of the following registry values to ensure its automatic start:
HKLMSOFTWAREMicrosoftWindowsCurrentVersionPoliciesExplorerRunservise=%path to the module’s executable file%
HKCUSoftwareMicrosoftWindows NTCurrentVersionWindowsload=%path to the module’s executable file%
Then, the module enters an infinite loop where it executes its main function with 300 second delay between iterations.
The module traverses the directories from a hardcoded list, looking for files with names matching regular expressions “.*..
*.bak” and “.*..*.trh”.
The list of directories:
%ProgramFiles%Microsoft Common %ProgramFiles%Common Files %SystemDrive%Documents and SettingsLocalServiceApplication DataMicrosoft %SystemDrive%Documents and SettingsLocalServiceLocal SettingsApplication DataMicrosoft %ALLUSERSPROFILE% %ALLUSERSPROFILE%Application Data %ALLUSERSPROFILE%Application DataMicrosoft %ALLUSERSPROFILE%Application DataMicrosoftOffice %ALLUSERSPROFILE%Application DataMicrosoftOfficeData %ALLUSERSPROFILE%Application DataMicrosoftWindows %windir%Installer %windir%HelpToursmmTour %windir%HelpTourshtmTour %windir%HelpToursWindowsMediaPlayer %windir%IME %windir%MsApps %windir%MsAppsMsInfo %windir%inf %HOMEPATH%Local Settings %APPDATA% %APPDATA%MicrosoftOffice %APPDATA%MicrosoftOfficeData %APPDATA%MicrosoftWindows %windir%Temp %TMP% %module’s installation directory%
Any found file with the extension “.trh” is deleted.
Files with the extension “.bak” are treated differently.
They are decrypted using a custom AMPRNG algorithm with a hardcoded key, then decompressed using LZMA.
If the file was decompressed without errors, it is expected to start with a header that describes an internal task.
Each task has a name and a “type” field.
Depending on that field, the module treats the contents of the decrypted file differently:
Known variants of the “.bak” task files were created by the “fileputexec” module.
They all contained a task named “fileinfo”.
Known file locations: add-on directories of Acrobat Reader or Microsoft Office, depends on installation settings.
Known variants:
The file is a PE DLL file with 1 exported function, compiled with Microsoft Visual Studio 2010.
The malware contains a universal plugin for Acrobat Reader and Microsoft Office application.
The plugin does not depend on the application so it could have been used with other applications, too.
Export(s): winampGetGeneralPurposePlugin
All the functionality is implemented in the DllMain function.
When loaded, the module starts a new thread and returns.
In the new thread, the module executes its main function in an infinite loop, with 1 second delay.
The module iterates through file handle values from 0 to 65534 with step 4, and tries to get file size for every handle.
If call to GetFileSize succeeds, the module assumes that it found a valid file handle, and proceeds with this file.
The file handle may belong to any file that is currently open by the application, including any open documents (i.e.
PDF, DOC, XLS, PPT files).
The module retrieves the name of the file, reads the whole file into memory and checks its last DWORD.
If the value is not equal to the magic number 0x29A (666 decimal), it skips this file.
If the DWORD matches the magic value, it reads more values from the end of file.
If the operation mode byte is equal to 3, the module loads the decrypted payload as a PE DLL library using own PE format loader, and executes its DllMain function.
If the operation mode byte contains any other value, it tries to write the payload to the first available directory from the list:
%windir%Temp %TMP% %TEMP% %ProgramFiles%Common Files %ProgramFiles%WindowsUpdate
The name of the file is read from the beginning of the decrypted payload.
Then, the module selects further actions depending on the operation mode byte:
Known variants:
The file is a PE DLL file without exported functions, compiled with Microsoft Visual Studio 2010.
All the functionality is implemented in the DllMain function.
When loaded, the module retrieves its resource of type “BBB” and name “AAA”, and starts an internal plugin framework.
The main function of the module is named “task_msplugin” and is registered in the framework.
Then, it starts the framework main loop, effectively parsing the resource data and executing the list of actions encoded in the resource.
The decoded resource data for the known sample can be represented as the following script:
SetOption(conn_a.VERSION_ID, [6] “51070”) SetOption(conn_a.VER_SESSION_ID, %removed%) SetOption(conn_a.SEND_DELAY_TIME, [5] “2000”) SetOption(conn_a.D_CONN, [65] “nt-windows-online.com;nt-windows-update.com;nt-windows-check.com”) SetOption(conn_a.D_MODE, “3”) SetOption(conn_a.D_NAME, [15] “/cgi-bin/nt/sk”) SetOption(conn_a.D_PASS, 0x00) SetOption(conn_a.D_RPRT, [3] “80”) SetOption(conn_a.D_SPRT, [3] “80”) SetOption(conn_a.D_USER, [21] %removed%) SetOption(conn_a.J_CONN, [65] “nt-windows-online.com;nt-windows-update.com;nt-windows-check.com”) SetOption(conn_a.J_MODE, 0x0033) SetOption(conn_a.J_NAME, [15] “/cgi-bin/nt/th”) SetOption(conn_a.J_PASS, 0x00) SetOption(conn_a.J_RPRT, [3] “80”) SetOption(conn_a.J_SPRT, [3] “80”) SetOption(conn_a.J_USER, [21] %removed%) SetOption(msplugin_loc, 76288 bytes buffer) SetOption(msplugin_name, 28 bytes buffer) SetOption(msplugin_Word, “1”) SetOption(msplugin_Excel, “0”) SetOption(msplugin_PowerPoint, “0”) SetOption(msplugin_desc0, 38 bytes buffer) SetOption(msplugin_desc1, 58 bytes buffer) SetOption(msplugin_desc2, 64 bytes buffer) SetOption(msplugin_progid, 22 bytes buffer) Call(task_msplugin)
First, the module tries to raise its privileges.
It tries to log in as a privileged user using a dictionary of common passwords.
Then, it tries to locate installed Microsoft Office application by enumerating the registry keys in HKLMSOFTWAREMicrosoftWindowsCurrentVersionUninstall and searching for the keys that contain “Microsoft Office”, “Microsoft Office Word”, “Microsoft Office Shared” in the “DisplayName” value.
If no key was found, the module aborts installation.
Then, depending on the values of the options “msplugin_Word”, “msplugin_Excel”, “msplugin_PowerPoint”, it installs a plugin for selected Office applications.
For each application, it tries to write the plugin to the first available directory from the list:
%ProgramFiles%Microsoft OfficeOffice10Data %ProgramFiles%Microsoft OfficeOffice10 %ProgramFiles%Microsoft OfficeOffice11Data %ProgramFiles%Microsoft OfficeOffice11 %ProgramFiles%Microsoft OfficeOffice12Data %ProgramFiles%Microsoft OfficeOffice12 %ALLUSERSPROFILE%Application DataMicrosoftOffice %ALLUSERSPROFILE%Application DataMicrosoftOfficeData %APPDATA%MicrosoftOfficeData %APPDATA%MicrosoftOffice %APPDATA%MicrosoftWindows %ProgramFiles%Microsoft Common %ProgramFiles%Common Files
The file name for the plugin is retrieved from the “msplugin_name” option from the resource.
It also generates a random CLSID value for the plugin.
If the file was created without errors, the module creates the following registry values:
HKLMSOFTWAREMicrosoftOffice%product name%Addins%msplugin_progid option value% LoadBehavior=DWORD:0x10 CommandLineSafe=DWORD:0x00 FriendlyName=%msplugin_desc1 option value% Description=%msplugin_desc2 option value%
HKCRCLSID%plugin’s CLSID% default=%msplugin_desc0 option value%
HKCRCLSID%plugin’s CLSID%InProcServer32 default=%plugin installation path%
HKCRCLSID%plugin’s CLSID%ProgID default=%msplugin_progid option value%
HKCRCLSID%plugin’s CLSID%VersionIndependentProgID default=%msplugin_progid option value%
HKCR%msplugin_progid option value%CLSID default=%plugin’s CLSID%
After completing the installation, the module sends its log file to the C&C server.
The connection options are retrieved from the configuration (resource):
The data send to the C&C server is compressed with Zlib and encrypted with a modified PKZIP stream cipher, and then it is Base64-encoded.
Known variants:
The file is a PE DLL file without exported functions, compiled with Microsoft Visual Studio 2010.
All the functionality is implemented in the DllMain function.
When loaded, the module retrieves its resource of type “BBB” and name “AAA”, and starts an internal plugin framework.
The main function of the module is named “task_arplugin” and is registered in the framework.
Then, it starts the framework main loop, effectively parsing the resource data and executing the list of actions encoded in the resource.
The decoded resource data for the known sample can be represented as the following script:
SetOption(conn_a.VERSION_ID, [6] “51070”) SetOption(conn_a.VER_SESSION_ID, %removed%) SetOption(conn_a.SEND_DELAY_TIME, [5] “2000”) SetOption(conn_a.D_CONN, [65] “nt-windows-online.com;nt-windows-update.com;nt-windows-check.com”) SetOption(conn_a.D_MODE, 0x0033) SetOption(conn_a.D_NAME, [15] “/cgi-bin/nt/sk”) SetOption(conn_a.D_PASS, 0x00) SetOption(conn_a.D_RPRT, [3] “80”) SetOption(conn_a.D_SPRT, [3] “80”) SetOption(conn_a.D_USER, [21] %removed% ) SetOption(conn_a.J_CONN, [65] “nt-windows-online.com;nt-windows-update.com;nt-windows-check.com”) SetOption(conn_a.J_MODE, 0x0033) SetOption(conn_a.J_NAME, [15] “/cgi-bin/nt/th”) SetOption(conn_a.J_PASS, 0x00) SetOption(conn_a.J_RPRT, [3] “80”) SetOption(conn_a.J_SPRT, [3] “80”) SetOption(conn_a.J_USER, [21] %removed% ) SetOption(arplugin_loc, 76288 bytes buffer ) SetOption(arplugin_name, 28 bytes buffer ) Call(task_arplugin)
The module retrieves the Adobe Reader installation path by reading the registry value:
HKLMSOFTWAREClassesSoftwareAdobeAcrobatExe@default
Then, it tries to identify the version of installed software by searching for strings “10.0”, “9.0”, “8.0” in the installation path.
If none of them are found, it aborts installation with error.
If installation path contains the string “10.0”, the module tries to open the existing registry key:
HKCUSOFTWAREAdobeAcrobat Reader10.0
If the key exists, then writes “Privileged=’ON'” into its log and sets the following registry key, effectively disabling the “protected mode” of the Adobe Reader:
HKCUSOFTWAREAdobeAcrobat Reader10.0PrivilegedbProtectedMode=0
Then, the module extracts the Acrobat Reader plugin body from the configuration option “arplugin_loc” (specified in the resource) and writes it to:
%acrobat reader installation path%plug_ins%arplugin_rem option value%
It also retrieves the last write time of the plug_ins directory and sets the plugin’s last write time to the same value.
After completing the installation, the module sends its log file to the C&C server.
The connection options are retrieved from the configuration (resource):
The data send to the C&C server is compressed with Zlib and encrypted with a modified PKZIP stream cipher, and then it is Base64-encoded.
Known variants:
The file is a PE DLL file without exported functions, compiled with Microsoft Visual Studio 2010.
Known samples share one code section, but contain different payloads in the resource section.
All the functionality is implemented in the DllMain function.
It writes files from its configuration resource to disk and starts a new process from these file(s).
When loaded, the module retrieves its resource of type “BBB” and name “AAA”, and starts an internal plugin framework.
The main function of the module is named “task_fileputexec” and is registered in the framework.
Then, it starts the framework main loop, effectively parsing the resource data and executing the list of actions encoded in the resource.
Decoded resource data for the module can be represented as the following script:
SetOption(conn_a.VERSION_ID, [6] “51070”) SetOption(conn_a.VER_SESSION_ID, %removed%) SetOption(conn_a.SEND_DELAY_TIME, [5] “2000”) SetOption(conn_a.D_CONN, [65] “nt-windows-online.com;nt-windows-update.com;nt-windows-check.com”) SetOption(conn_a.D_MODE, 0x0033) SetOption(conn_a.D_NAME, [15] “/cgi-bin/nt/sk”) SetOption(conn_a.D_PASS, 0x00) SetOption(conn_a.D_RPRT, [3] “80”) SetOption(conn_a.D_SPRT, [3] “80”) SetOption(conn_a.D_USER, [21] %removed%) SetOption(conn_a.J_CONN, [65] “nt-windows-online.com;nt-windows-update.com;nt-windows-check.com”) SetOption(conn_a.J_MODE, 0x0033) SetOption(conn_a.J_NAME, [15] “/cgi-bin/nt/th”) SetOption(conn_a.J_PASS, 0x00) SetOption(conn_a.J_RPRT, [3] “80”) SetOption(conn_a.J_SPRT, [3] “80”) SetOption(conn_a.J_USER, [21] %removed%) SetOption(file_loc) SetOption(file_rem) SetOption(file_exec_rem) SetOption(file_loc, 156898 bytes buffer ) SetOption(file_rem, 100 bytes buffer ) Call(task_fileputexec)
The module implements two distinct functions:
It writes files from its configuration resource to disk
It starts executable files specified in the resource
First, the module looks for pairs of configuration options called “file_rem” and “file_loc”.
The module iterates through all “file_rem” options, reads the corresponding “file_loc” value and writes the contents of the latter option to disk, using the value of “file_rem” as a filename.
The “file_rem” value can specify a location at another computer’s network share.
In this case the module tries to log onto that share using credentials specified in an encrypted configuration file that may be located at:
%ALLUSERSPROFILE%adt.dat %LOCALAPPDATA%adt.dat
Known variants of the module were used to write another module called “scheduler” and additional files for this module.
After processing all “file_rem” and “file_loc” options, the module iterates through all values of the “file_exec_rem” option.
Each value is expected to be an applications path, and each application is executed using the CreateProcess API function.
After processing all the configuration options, the module sends its log file to the C&C server.
The connection options are retrieved from the configuration (resource):
The data sent to the C&C server is compressed with Zlib and encrypted with a modified PKZIP stream cipher, and then it is Base64-encoded.
Known variants:
The file is a PE DLL file without exported functions, compiled with Microsoft Visual Studio 2010.
All the functionality is implemented in the DllMain function.
Once it is loaded it was designed to start scanning other hosts in the network and record responses.
It would do several probes for remote vulnerabilities, such as MS08-067.
It is capable of dumping current configuration of Cisco routers if they are available via SNMP and the scanner successfully guessed the SNMP community name.
This module loads a config from local resource AAA and executes a network scanning task.
Due a design made by the developer usage of this module is limited.
It seems that it was developed and tested as an EXE file, however in the release version it was compiled as a DLL.
This change was extremely significant for the whole functionality which creates a number of worker threads right in the main function, which is would be fine for EXE module WinMain function, but is restrcited for library DllMain function.
This broke down the module as it created threads which couldn’t run when DLL is loaded via LoadLibrary API.
However, it’s important to note that the developers implemented own PE loader, which doesn’t have such limitation as Window native PE loader, and which is why it can still be used as a component of malicious kit.
Current sample has the following embedded config:
SetOption(conn_a.D_CONN, [65] “nt-windows-online.com;nt-windows-update.com;nt-windows-check.com”) SetOption(conn_a.D_NAME, [15] “/cgi-bin/nt/sk”) SetOption(conn_a.D_RPRT, [3] “80”) SetOption(conn_a.D_SPRT, [3] “80”) SetOption(conn_a.D_USER, [21] “%removed%”) SetOption(conn_a.D_MODE, 0x0033) SetOption(conn_a.D_PASS, 0x00) SetOption(conn_a.J_CONN, [65] “nt-windows-online.com;nt-windows-update.com;nt-windows-check.com”) SetOption(conn_a.J_NAME, [15] “/cgi-bin/nt/th”) SetOption(conn_a.J_USER, [21] “%removed%”) SetOption(conn_a.J_RPRT, [3] “80”) SetOption(conn_a.J_SPRT, [3] “80”) SetOption(conn_a.J_MODE, 0x0033) SetOption(conn_a.J_PASS, 0x00) SetOption(conn_a.VERSION_ID, [6] “51070”) SetOption(conn_a.SEND_DELAY_TIME, [6] “20000”) SetOption(conn_a.VER_SESSION_ID, [11] “%removed%”) SetOption(NET, [26] “127.0.0.1 255.255.255.255”) SetOption(netscan_get_NET, “1”) SetOption(netscan_get_net_ad, “1”) SetOption(netscan_get_net_msnet, “1”) SetOption(netscan_get_net_msdom, “1”) SetOption(netscan_threads_num, [3] “64”) SetOption(netscan_tcpscanwinsrv, “1”) SetOption(netscan_tcpscanwin, “0”) SetOption(netscan_tcpscannotwin, “0”) Call(task_netscan)
The target networks to scan are selected automatically and include the following lists:
specified in the config NET variable if netscan_get_NET is set to 1
subnets of IPs which are visible from adapters config via GetAdaptersInfo API (current IP, gateway, DHCP, WINS servers)
subnets of IPs which are visible in the list of currently mapped shared folders
subnets of IPs which are part of current Microsoft Windows domain as reported by the Domain Controller
The scan begins with pinging the target with 2 seconds timeout.
Then the scanner gets target hostname and MAC address.
After that it tries to send an SNMPv3 request.
Unlike SNMPv2, SNMPv3 responds even if the username is wrong allowing you to identify if the port is open or not.
If the remote SNMP agent responds, then the scanner will try to talk further.
SNMP packet from malware in Wireshark
It tries to guess the SNMP agent community name from a list of 600 hardcoded variants.
The list itself interesting enough as it seems to be made of previously discovered SNMP agent community names from various locations where the attackers managed to penetrate networks.
We are sharing the list, maybe it will help someone identify his SNMP community name and will cause further network checks:
