The Angler Exploit Kit (EK) recently added support for an Internet Explorer (IE) vulnerability (CVE-2015-2419) that was patched in July 2015.
Quickly exploiting recently patched vulnerabilities is standard for Angler EK authors, but the target has been Adobe Flash Player since the second half of 2014.
The exploitation of CVE-2015-2419 marks the second departure from Flash exploits for Angler (the first being the inclusion of CVE-2015-1671 in Silverlight).
This may be the result of Adobe’s recent exploit mitigations in Flash Player that prevent attackers from using Vector (and similar) objects to develop their control over corrupted Flash processes.
To date, Angler will deliver Flash, IE, and/or Silverlight exploits depending upon the target’s environment.
Angler also added a new obfuscation to its IE exploit.
The landing page fetches a stub of keys and data necessary to run the exploit from the server each time it executes.
The stub of information is only sent to victims that broadcast vulnerable browsers, and is protected with XTEA over a homebrew Diffie-Hellman.
Angler’s landing page is obfuscated in a mix of HTML and Javascript (JS).
Underneath the first layer of obfuscation, the landing page profiles the environment, selects exploits to launch, and launches the exploits.
The IE exploit is further obfuscated, and uses a key sharing (Diffie-Hellman (D-H)) cryptosystem to tailor each attack to an individual victim’s machine.
The crypto implementation uses library code from at least jsbn.js (BigInteger implementation in JavaScript), and bears similarities to cryptico.js.
The victim’s browser will POST the following JSON to the attacker’s server.
The naming convention follows a typical naming convention for the D-H protocol where g is the base, p is the modulus, and A is (g**a_) mod p (where a_ the victim’s secret exponent that is not transmitted on the wire).
There system takes little care in the safety of these values.
They are chosen from the cryptographically unsafe Math.random (in a custom and imbalanced way that prefers nibbles 0-9 over a-f), small, and without primality tests.
Value v is the result from ScriptEngineBuildNumber(), which identifies the build of jscript9.
The attacker responds with a base64 encoded version of the following.
B is the attacker’s D-H response ((g**b_) mod p where b_ is the attacker’s secret exponent that is not transmitted).
k is an encrypted version of a key used to decrypt B.
The attacker generates k by XTEA encrypting a random key with the D-H shared key (s = (A**b_) mod p).
The victim XTEA decrypts k, and then XTEA decrypts b.
{"B":"194ff891862b55d9f1cf5ce4a10f7f92","k":"GulSjPCeuXPcH%2BvwrHjzew%3D%3D","b":"liTB9J%2FghlAzk%2Bp9Kgbg0Y85WPNx1N0jP8u7qPuXo…”} b contains constants for the rest of the exploit (in the appendix in its entirety).
The constants are accessed through a couple layers of redirection in the exploit so that anyone performing static analysis of the attack wouldn’t have the complete exploit.
They would have the code flow, but none of the constants (e.g., “ur0pqm8kx”, the password to decrypt the shellcode or "stringify" the method name called from JSON).
Furthermore, attempts to replay the exploit files will fail because the D-H secret key will be lost.
A new random D-H g, A, and p will be created, and won't match the old attacker’s response.
As a result, the decryption of the D-H shared secret s will be wrong, as will the decryption results of k and b, and the exploit will fail.
The most obvious ways to observe the attack are to:
1) Break the crypto 2) Break the PRNG 3) “Do it live”
It is unclear why the attacker chose to protect only the constant values in the exploit instead of the entire exploit.
The decision seems like an unnecessary complication.
CVE-2015-2419 is a double free vulnerability in jscript9’s native JSON APIs that was patched in July with MS15-065.
Specifically, the vulnerability exists in the way that JSON.stringify parses deeply nested JSON data as follows.
The attacker’s chosen arguments to JSON.stringify are reproduced in their entirety in the appendix.
This exploit depends on the version of jscript9.dll.
In the decoded JSON response above, we can see the key value pairs corresponding to different versions of jscript9.dll
We can also confirm the version targeted from the following code section:
The shellcode is present inside the IE exploit deobfuscated page as RC4 encrypted and base64 encoded.
The key to decrypt the shellcode is also fetched from the above decoded JSON response.
In our case, the decryption key is: ur0pqm8kx.
The decryption subroutine is mentioned in Appendix II.
This latest IE exploit is being used to download the Cryptowall ransomware similar to other variants of Angler Exploit Kit observed in the past few months.
The payload is downloaded encrypted over the network.
The URL to download the payload is fetched as shown below:
Here, a is fetched from the above decoded JSON response.
In our case, it is xexec.
xexec() is a custom function which uses a key on the exploit kit landing page to decrypt the path from where the payload has to be fetched.
encrypted_path is present on the exploit kit landing page.
Using the decryption routine mentioned in Appendix I, this decrypts to the following base64 encoded data:
This base64 decodes to: " father.mhtml?fire=eo0&color=TD6nQ&federal=eUpwxsH&anything=b-5&set=GxMmUmpVak&organization=Vu1PaWIELYN_rO0b6gJm"
This is the path from which payload is served
The payload fetched from above path is encrypted.
It will be decrypted using XTEA algorithm by the shellcode.
The XTEA key used is present in the deobfuscated HTML page.
In our case, it is: Du9JOBgkbfzGvmFF.
Decryption routine to fetch payload path.
The key is present on exploit kit landing page.
RC4 decryption routine to fetch shellcode:
Contents of the b constant:
Attacker’s chosen arguments to JSON.stringify to exercise CVE-2015-2419:
We would like to thank Aakash Jain for his contributions to this blog.
