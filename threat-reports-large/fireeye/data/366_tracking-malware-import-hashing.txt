Tracking threat groups over time is an important tool to help defenders hunt for evil on networks and conduct effective incident response.
Knowing how certain groups operate makes for an efficient investigation and assists in easily identifying threat actor activity.
At Mandiant, we utilize several methods to help identify and correlate threat group activity.
A critical piece of our work involves tracking various operational items such as attacker infrastructure and email addresses.
In addition, we track the specific backdoors each threat group utilizes - one of the key ways to follow a group's activities over time.
For example, some groups may favor the SOGU backdoor, while others use HOMEUNIX.
One unique way that Mandiant tracks specific threat groups' backdoors is to track portable executable (PE) imports.
Imports are the functions that a piece of software (in this case, the backdoor) calls from other files (typically various DLLs that provide functionality to the Windows operating system).
To track these imports, Mandiant creates a hash based on library/API names and their specific order within the executable.
We refer to this convention as an "imphash" (for "import hash").
Because of the way a PE's import table is generated (and therefore how its imphash is calculated), we can use the imphash value to identify related malware samples.
We can also use it to search for new, similar samples that the same threat group may have created and used.
Though Mandiant has been leveraging this technique for well over a year internally, we aren't the first to publicly discuss this.
An imphash is a powerful way to identify related malware because the value itself should be relatively unique.
This is because the compiler's linker generates and builds the Import Address Table (IAT) based on the specific order of functions within the source file.
Take the following example source code:
When that source file is compiled, the resulting import table looks as follows:
We abbreviated the table to save space, but the red/bolded APIs are the ones referenced in the source code.
Note the order in which they appear in the table, and compare that to the order in which they appear in the source file.
If an author were to change the order of the functions and/or the order of the API calls in the source code, this would in turn affect the compiled import table.
Take the previous example, modified:
In this example, we have reversed the order of makeMutexW and makeMutexA, and of InternetConnectA and InternetOpenA.
(Note that this would be an invalid sequence of API calls, but we use it here to illustrate the point.)
Below is the import table generated from this modified source code (again abbreviated); note the changes when compared to the original IAT, above, as well as the different imphash value:
The final example shows how the ordering of included files at compile time will affect the resulting IAT (and thus the resulting imphash value).
We'll expand on our original example by adding files imphash1.c and imphash2.c, to be included with our original source file imphash.c:
Using the following command to build the EXE:
The resulting IAT is:
Changing the order of includes for imphash1.h and imphash2.h within the source file imphash.c will have no effect on the ordering of the IAT.
However, changing the order of the files on the command line and recompiling will affect the IAT; note the re-ordering of CreateNamedPipeW and CreateNamedPipeA:
These examples show that both the ordering of functions within the original source code - as well as the ordering of source files at compile time - will affect the resulting IAT, and therefore the resulting imphash value.
Because the source code is not organized the same way, two different binaries with exactly the same imports are highly likely to have different import hashes.
Conversely, if two files have the same imphash value, they have the same IAT, which implies that the files were compiled from the same source code, and in the same manner.
For packed samples, simple tools or utilities (with few imports and, based on their simplicity, likely compiled in the same way), the imphash value may not be unique enough to be useful for attribution.
In other words, it may be possible for two different threat actors to independently generate tools with the same imphash based on those factors.
However, for more complex and/or custom tools (like backdoors), where there are a sufficient number of imports present, the imphash should be relatively unique, and can therefore be used to identify code families that are structurally similar.
While files with the same imphash are not guaranteed to originate from the same threat group (it's possible, for example, for the files were generated by a common builder that is shared among groups) the files can at least be reasonably assumed to have a common origin and may eventually be attributable to a single threat group with additional corroborating information.
Employing this method has given us great success for verifying attacker backdoors over a period of time and demonstrating relationships between backdoors and their associated threat groups.
Mandiant has submitted a patch that enables the calculation of the imphash value for a given PE to Ero Carrera's pefile (http://code.google.com/p/pefile/).
Mandiant uses an imphash convention that requires that the ordinals for a given import be mapped to a specific function.
We've added a lookup for a couple of DLLs that export functions commonly looked up by ordinal to pefile.
Mandiant's imphash convention requires the following:
Resolving ordinals to function names when they appear
Converting both DLL names and function names to all lowercase
Removing the file extensions from imported module names
Building and storing the lowercased string .
in an ordered list
Generating the MD5 hash of the ordered list
This convention is implemented in pefile.py version 1.2.10-139 starting at line 3618.
If imphash values serve as relatively unique identifiers for malware families (and potentially for specific threat groups), won't discussing this technique alert attackers and cause them to change their methods?
Attackers would need to modify source code (in a way that did not affect the functionality of the malware itself) or change the file order at compile time (assuming the source code is spread across multiple files).
While attackers could write tools to modify the imphash, we don't expect many attackers to care enough to do this.
We believe it is important to add imphash to the lexicon as a way to discuss malware samples at a higher level and to exchange information about attackers and threat groups.
For example, incident responders can use imphash values to discuss malware without specifically disclosing which exact sample (specific MD5) is being discussed.
Consider a scenario where an attacker compiles 30 variants of its backdoor with different C2 locations and campaign IDs and deploys them to various companies.
If a blog post comes out stating that a specific MD5 was identified as part of a campaign, then based on that MD5 the attacker immediately knows what infrastructure (such as C2 domains or associated IP addresses) is at stake and which campaign may be in jeopardy.
However, if the malware was identified just by its imphash value, it is possible that the imphash is shared across all 30 of the attacker's variants.
The malware is still identifiable by and can be discussed within the security community, but the attacker doesn't know which specific samples have been identified or which parts of their infrastructure are in jeopardy.
To demonstrate the effectiveness of this analysis method, we've decided to share the imphash values of a few malware families from the Mandiant APT1 report:
