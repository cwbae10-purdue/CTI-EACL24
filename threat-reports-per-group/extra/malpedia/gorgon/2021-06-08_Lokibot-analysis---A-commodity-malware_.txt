Lokibot it’s not new but it’s a common malware to see these days since it’s sold on underground websites, thus it’s available to the average cyber-criminal.
This malware is designed to steal information from infected machines and send it to a command and control server using HTTP POST requests.
Besides stealing data, it can set up persistence, receive tasks from the C2 server, and it can be used to download more malware.
Lokibot has been around for a few years now, but the statistics show that is still very common to see Lokibot being used.
The stats provided by Any Run show that this family is within the top 3 of the Global rank and the top 10 of both the Week and Month ranks.
The stats from MalwareBazaar put this family within the top 10 of all time of the most seen malware families.
Tria.ge stats place Lokibot in the top 5 of submissions.
Given the popularity of this malware and my curiosity, I decided to take a look at a sample and see how it works.
The sample I used in this analysis can be found here.
Lokibot resolves most of the needed APIs during the execution.
To avoid hardcoding the original API names, the malware uses hashes of the API names whenever it needs to resolve them.
The first step to moving forward with the reverse engineering of this sample I had to understand how Lokibot resolves the APIs and how the algorithm that computes the hashes works.
To resolve a Windows API, Lokibot calls an auxiliary function that receives an index value and a hash of the API name as arguments.
The indexes are used to get the DLL name from an in-memory array containing the DLL names.
To get the final addresses Lokibot loads and parses the export table from the DLLs.
For each API in the export table, Lokibot computes a hash of its name and compares it with the hash passed to the function as an argument.
Pseudo code of the hashing algorithm used by this Lokibot sample:
Using my own implementation of this algorithm in python I was able to build a list containing the Windows API names alongside their hashes.
In this gist, you can find the full list containing the API names and the hashes.
Before starting any actions the malware checks if there is a -u switch in the arguments of the process and if it finds it the execution is delayed for 10 seconds.
This switch is used when Lokibot upgrades itself.
Lokibot uses Berkeley compatible sockets for communications and because of that, it needs to call WSAStartup() before using any other networking functions.
If the call succeeds the malware tries to create a mutex based on the MD5 hash of the machine GUID (trimmed to 24 chars).
Mutexes are used to guarantee that there is only one instance of a program running on a system.
Lokibot calls a function that will build two large arrays in the stack.
The first array will contain the identifiers of the functions, and the second array the actual routines that steal data.
After building the two arrays, the functions that steal data are executed using a wrapper function.
This wrapper function sets a global variable with the identifier of the steal function and executes it.
This way, Lokibot can keep a reference between the stolen data and the function that stole it in the reported data.
This way, when parsing the stolen data the C2 server will know how to process/store it.
List of all the targeted applications and files:
After getting all the data and save it in a memory buffer, Lokibot will prepare the data and report it back to the C2 server.
The configured C2 server is encrypted using Triple-DES and gets decrypted on runtime.
The malware grabs information about the local system and builds a report packet.
This packet will have the system information, stolen data, and some other flags and data.
Summary of the system information that is collected to build the report packet:
An interesting bit of information on the Lokibot communications is the user-agent.
A simple google search shows nothing but only references to this malware.
After stealing the data from the targeted applications, Lokibot will try to steal data from the Windows Credential Manager.
To steal those credentials, Lokibot will search any files within the following directories:
To decrypt the passwords, Lokibot tries to inject code into the Local Security Authority Subsystem Service process (lsass.exe).
The injection will occur only if:
A fun fact about the x86 injection function is that the author forgot to create a remote threat after writing the shellcode into the Lsass process, meaning that the shellcode is written but never executed.
After stealing this data, Lokibot builds a new report packet and reports it back to the C2 server.
For persistence, Lokibot copies itself to a folder inside the %APPDATA% folder, creates a new run key, and hides both the created directory and the copied executable.
Creating the directory and copying the original executable:
Creating a run key and hiding both the folder and the executable:
This way whenever the system is started the hidden executable will be executed.
After stealing the data, Lokibot is also able to fetch tasks from the C2 server.
Summary of the possible Lokibot tasks:
Here is a snippet of a function that will download additional executables and execute them:
Lokibot creates a hidden folder within the %APPDATA% directory.
The directory name will be a slice of the mutex name (8th char - 13th char).
In the hidden directory, Lokibot creates four files at any given time with the following extensions:
The file names will also be a slice of the mutex name (13th char - 18th char) followed by the extension.
The user-agent used by Lokibot is also very uncommon which can be used to build simple detections.
List of existing Suricata rules:
