Protect your devices, your data, and your privacy—at home or on the go.
"Thanks to the Malwarebytes MSP program, we have this high-quality product in our stack.
It’s a great addition, and I have confidence that customers’ systems are protected."
Activate Malwarebytes Privacy on Windows device.
Posted: October 24, 2016 by Malwarebytes Labs

Last updated: November 19, 2020
Recently, our analyst Jérôme Segura captured an interesting payload in the wild.
It turned out to be a new bot that, at the moment of analysis, hadn’t been described yet.
According to strings found inside the code, the authors named it TrickBot (or “TrickLoader”).
Many links indicate that this bot is another product of the threat actors previously behind Dyreza, a credential-stealer.
While TrickBot seems to be written from scratch, it contains many similar features and solutions to those we encountered analyzing Dyreza.
The payload was spread via malvertising campaign, which dropped the Rig EK:
After being deployed, TrickBot copies itself into %APPDATA% and deletes the original sample.
It doesn’t change the initial name of the executable, however.
(In the given example, the analyzed sample was named “trick.exe”.)
First, we can see it dropping two additional files: client_id and group_tag.
They are generated locally and used to identify, appropriately, the individual bot and the campaign to which it belongs.
The content of both files is not encrypted; it contains text in Unicode.
An example of the client_id consists of the name of the attacked machine, operating system version, and a randomly-generated string:
Then, in the same location, we can see config.conf appearing.
This file is downloaded from the C&C and stored in encrypted form.
After some time, we can see another folder being created in %APPDATA% named Modules.
The malware drops additional modules downloaded from the C&C, which are also stored encrypted.
In a particular session, TrickBot downloaded modules called injectDll32 and systeminfo32:
This particular module may also have a corresponding folder where its configuration is stored.
The pattern of the naming convention is [module name]_configs.
When we observe the execution of the malware via monitoring tools, i.e.
ProcessExplorer, we can find it deploying two instances of svchost:
The bot achieves persistence by adding itself as a task in Windows Task Scheduler.
It doesn’t put any effort in hiding the task under a legitimate name, and instead just calls it “Bot.”
If the process is killed, it is automatically restarted by the Task Scheduler Engine:
TrickBot connects to the several servers:
First, it connects to a legitimate server myexternalip.com in order to fetch the IP visible from outside.
The interesting part is that it doesn’t try to disguise as a legitimate browser.
Instead, it uses its own User Agent: “BotLoader” or “TrickLoader.”
Most—but not all—of the communication with its main C&C is SSL encrypted.
Below, you can see an example of one of the commands sent to the C&C:
Looking at the URL of POST request, we notice the group_id and the client_id that are the same as in the files.
After that, the command id follows.
This format was typical for Dyreza.
The bot also downloads an additional payload (in the particular session it was: 47d9e7c464927052ca0d22af7ad61f5d) without encrypting the traffic:
C&Cs are set up on hacked wireless routers, such as MikroTik.
This way of setting up the infrastructure was also previously used by Dyreza.
In this example of a used HTTPs certificate, we can see that the used data is fully random and not even trying to imitate legitimate-looking names:
TrickBot is composed of several layers.
As usual, the first layer is used for protection: It carries the encrypted payload and tries to hide it from AV software.
The second layer is a main bot loader that chooses whether to deploy a 32-bit or 64-bit payload.
New PE files are stored in resources in encrypted form.
However, the authors didn’t try to hide the functionality of particular elements, and looking at the names of the resources, we can easily guess what their purpose is:
Selected modules are decrypted during execution.
At the beginning, the application fetches information about the victim’s operating system in order to choose the appropriate way to follow:
Depending on the environment, a suitable payload is picked from resources, decrypted by a simple algorithm, and validated:
The decrypting procedure is different than the one found in Dyreza, however, the general idea of organizing content (three encrypted modules in resources) is analogous.
See full decoding script: https://github.com/hasherezade/malware_analysis/blob/master/trickbot/trick_decoder.py
Returning to our malware analysis, next, the unpacked bot is mapped to the memory by a dedicated function and deployed.
The 32-bit bot maps the new module inside its own memory (self-injection):
and then redirects execution there:
Entry point of the new module (TrickBot core):
In the case of 64-bit payload being chosen, first the additional executable—a 64bit PE loader—is unpacked and run.
Then it loads the core, malicious bot.
In contrast to Dyreza, whose main modules were DLLs, TrickBot uses EXEs.
The bot is written in C++.
It comes with two resources with descriptive names: CONFIG, which stores encrypted configuration, and KEY, which stores the Elliptic Curve key:
In general, this malware is verbose: meaningful names can be found at every stage.
The name “TrickBot” also appears in the name of the global mutex (“Global\\TrickBot”) created by the application in order to ensure that it is run only once:
At first execution, TrickBot copies itself into a new location (in %APPDATA%) and deploys the new copy, giving as an argument path to the original one that needs to be deleted:
Adding a task of running bot into the Task Scheduler:
We can find the date pointing to the beginning of 2016, which may confirm the observation that the bot is new, and was written this year.
TrickBot communicates with its C&C and sends several commands in a format similar to the one used by Dyreza.
Below is list of format strings used by TrickBot commands:
Compare that with Dyreza’s command format:
TrickBot’s command IDs are hardcoded in the format strings.
However, all of them are deployed from inside the same function that gets the command ID as a parameter:
After filling the appropriate format string and sending it to the C&C, the bot checks the HTTP response code.
If the returned code is different than 200 (OK), 403 (Forbidden), or 404 (Not found), then it tries again.
Here’s a full list of implemented command IDs:
Each command has the same prefix – that is a group id of the campaign and bot’s individual id (the same data that are stored in dropped files).
More notes about the protocol here.
TrickBot uses alternatively two encryption algorithms: AES and ECC.
The downloaded modules and configuration are encrypted by AES in CBC mode.
The AES key and initialization vector are derived from the data, by a custom, predefined algorithm.
First, 32 bytes of input data is hashed, using SHA256.
Then, the output of the hashing function is appended to the data buffer and hashed again.
This step is repeated until the full size of data in buffer become 4096.
So, the hashing operation repeats 128 times.
Below you can see the responsible fragment of code:
First 32 byte long chunk of data is used as a initial value to derive AES key:
And bytes from 16 to 48 are used as a initial value to derive AES initialization vector:
Compare with the content of CONFIG (mind the fact that the first DWORD is a size, and is not included in the data):
Full decoding script you can find here: https://github.com/hasherezade/malware_analysis/blob/master/trickbot/trick_config_decoder.py
Decrypting hardcoded configuration using AES:
In case if particular input could not be decrypted via AES, the attempt is made to decrypt it via ECC:
Similarly to Dyreza, TrickBot uses configuration files, that are stored encrypted.
Trick Bot’s executable comes with a hardcoded configuration, that, during execution is substituted by its fresh version, downloaded from the C&C and saved in the file config.conf.
Below you can see the decrypted content of the hardcoded one:
Compare it with a downloaded one – version number got incremented, and some C&Cs have changed:
Notice that names of the listed modules (systeminfo, injectDll) are corresponding to those, that we found in the folder Modules during the behavioral analysis.
It is due to the fact, that this configuration gives instructions to the bot, and orders it to download particular elements.
Some of the requests result in downloading additional pieces of configuration.
Example of the response, after being decrypted by the bot:
TrickBot is a persistent botnet agent – but its main power lies in the modules, that are DLLs dynamically fetched from the C&C.
During the analyzed session, the bot downloaded two modules.
List of the attacked browser is hardcoded in the injectDll32.dll:
It case of the Dyreza, this attack was performed directly from the main bot, rather than from the added DLL.
Details of the attacked target are given in an additional configuration file, stored in the folder: Modules\injectDll32_config.
Below we can see its decrypted form revealing the attacked online-banking systems:
The instances of svchost.exe, observed during the behavioral analysis, are used to deploy particular modules.
Below – the module injectDll (marked sinj) in memory of svchost:
and the module systeminfo (marked GetSystemInfo) in memory of the another instance of svchost:
Trick Bot have many similarities with Dyreza, that are visible at the code design level as well as the communication protocol level.
However, comparing the code of both, shows, that it has been rewritten from scratch.
So far, Trick Bot does not have as many features as Dyreza bot.
It may be possible, that the authors intentionally decided to make the main executable lightweight, and focus on making it dynamically expendable using downloaded modules.
Another option is that it still not the final version.
One thing is sure – it is an interesting piece of work, written by professionals.
Probability is very high, that it will become as popular as its predecessor.
http://www.threatgeek.com/2016/10/trickbot-the-dyre-connection.html – analysis of the TrickBot at Threat Geek Blog
This was a guest post written by Hasherezade, an independent researcher and programmer with a strong interest in InfoSec.
She loves going in details about malware and sharing threat information with the community.
Check her out on Twitter @hasherezade and her personal blog: https://hshrzd.wordpress.com.
Malware | Threat analysis | Threat Intelligence
 November 30, 2020 - After a noted absence, the Gootkit banking Trojan returns en masse to hit Germany.
In an interesting twist, some of the victims may receive ransomware instead.
Malware | Malwarebytes news | Threat analysis
 November 22, 2017 - The Terdot Trojan is a banker, but it loves to steal your social networks credentials as well.
 August 18, 2017 - The first part of this research looks at the tricks used by the Kronos banking malware.
Cybercrime | Malware | Malware | Threat analysis
 January 26, 2017 - Recently, among the payloads delivered by exploit kits, we often find Terdot.A/Zloader - a downloader installing on the victim machine a ZeuS-based malware.
 February 29, 2016 - With the returned popularity of visual basic as a first attack vector in mind, we took a look at de-obfuscating a few recent vbs files starting with a very easy one and progressing to a lot more complex script.
Want to stay informed on the latest news in cybersecurity?
Sign up for our newsletter and
                            learn
                            how to protect your computer from threats.
Imagine a world without malware.
Your intro to everything relating to cyberthreats, and how to stop them.
