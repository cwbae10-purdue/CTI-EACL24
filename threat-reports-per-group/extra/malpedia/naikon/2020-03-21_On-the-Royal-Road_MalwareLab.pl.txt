Royal Road or 8.t is one of the most known RTF weaponizer, its used and shared mostly amongst Chinese speaking actors - there are also couple very good publications including one form nao_sec, Sebdraven and Anomali.
It was on my todo list for some time, and thanks to recent twitter discussion as well as quarantine time i finally took a deeper look at it.
We’ll go into how to quickly analyze RTF maldocs,
quickly tear-down shellcode used and finally how to extract embedded payload.
Document that will be used as an example caused a discussion on twitter regarding actor behind this attack due to some code overlap of a dropped payload.
From output above we can assume that document attempts to exploit a bug in Equation Editor so object number 1 will most likely contain a shellcode and will be a target of our analysis.
Let’s throw it in our favorite disassembler.
Unfortunately IDA doesn’t reveal any code which hints us that somewhere there there is a decoding stub, responsible for decoding actual shellcode.
Indeed we can find one at offset 6Ah
When analyzing shellcodes used in Equation Editor exploits i prefer to look for a bytes indicating jumps or calls instead of parsing structure of a file, this yields quicker results and allows to throw out garbage bytes like here at the begin of a file.
Anyhow here we have a typical jump-into-instruction and short xoring loop.
Nothing that can’t be solved with a bit of scripting.
To make it more fun, will make it a generic
This will take care of our problem.
It is also worth noticing that this stub is pretty uncommon due to comparison to zero at 7Ah which makes it pretty good candidate for YARA signature!
something like that should do the trick.
Note that we have hex encoded version for upper and lower cases.
But enough of this digression, lets get back to our shellcode.
At first glance, decompilation of main shellcode function doesn’t look very nice, but we can make it work.
If one scroll down a little it’s actually pretty easy to find a decoding loop and make an educated guess that this will decode a payload, but this time will do it step by step.
First when dealing with shellcodes (or generally with most malwares) its important to find how it utilize API calls.
In most cases there will be a search for library addresses by walking a PEB and later parsing PE files and applying some sort of hashing in order to resolve imports.
At offset b67h there is a function that will resolve all necessary imports.
After looking at sub_70A we found out that hashing algorithm is ror7
After this quick analysis we know that:
Lets create a script that will create CTX objects for us.
First we need a list of API names, here mlib has you covered as it exposes couple thousands of standard APIs one can found in windows dll’s.
Rest is just a matter of creating and naming a structure members.
And soon after applying this and some more types we can get a nice clear view of a main function
This will be enough to continue analysis of a campaign, as we can now switch to decoding payload and analyze whats there, however its sometimes worth to dig a little deeper into and uncover some interesting flavors that are inside.
We will do exactly that.
We skipped over analysis of how exactly api is resolved, lets apply some types first and take another look.
First thing that will strike us is that it walks IMAGE_DATA_DIRECTORY instead of EXPORTS, indeed get_api function (located at 70Ah) will recive as a frist argument
pointer to begin of msvcrt.dll and will relay on addresses resolved when this librarly was loaded.
This is a very nice anti-analysis trick, as this library is not automatically loaded, and can cause some problems when analyzing shellcode outside of it designed host.
After address is resolved 5 is being added to it, this is strange!
Keep it in mind and lets move to function located at 7B7h.
This function will make sure that we have GetProcAddr and VirtualProtect as well will try to resolve address of clearerr from msvcrt.dll (via GetProcAddr).
In order to call any of those APIs we have to go through a wrapper at 8AEh and eventually we will reach function at 8D5h that will call our pointer, but before that it will do some checks.
Here lays the mystery of those +5 from get_api, before API is called first few bytes of its prologue are checked.
Any experienced eye can immediately recognize right hand values as an encoding of call or jmp asm opcodes.
If it detects hooking it will skip first 5 bytes emulating typical function prologue, thus rendering most of user-mode api loggers useless.
After address clearerr is resolved, it content is overwritten with bytes from 8AEh to 8FDh which contains functions responsible for anti-hooking call proxy.
There is another nice trick here, as the address of interesting area is dynamically calculated
Here, beside call-pop technique, we can see that address that will be called from 8A9h is extracted allowing to put interesting region anywhere in binary.
Along side their publication researchers at nao_sec released a tool that can help decode embedded payload into proper PE file.
They realized that keys used to bootstrap decoding algorithm in shellcode are reused
and first 4 bytes of encoded binary will always be the same.
They found 4 different algorithms and 4 diffrent keys, all of the algorithms look more or less the same and have a shape of the one discussed earlier.
It is important to notice that in their code two decoding functions (decode_b25a6f00 and decode_b2a66dff) are totally different than what one can see in binaries, those are simple xors with one byte.
Lets take a look at decode_b2a66dff:
This function will very quickly reach 0xfffffffc and is degenerating whole encoding scheme to just a xor with constant byte 0xfc.
Lets split the line into simpler components
Problem lies in v7&4 which will keep its bit light up forever after the first time it will be set to 1.
This is because it will be XORed with 1 bit variable and ORed with a value multiplied by 2.
Unfortunately these mistakes are not present in every version, hence more elaborate codes in rr_decode.py.
This script can of course take care of other schemas but it take some time when dealing with bigger binaries:
This is a problem for our automatic processing.
Maybe we can do something about it?
Lets take a look at this one,
can we somehow optimize expression assigned to v9?
It turns out we can!
;]
Lets expand it a little bit this part ((9 ^ ((v9 ^ (v9 >> 26)) >> 3))&1 using the fact that (x ^ y ) >> z is the same as (x >> z) ^ (x >> z).
We’ll end up with (v9 ^  ((v9>>27)>>3) ^ (v9>>3))&1.
We can see here that the whole expression is being anded with 1, meaning we only care about one bit of this operation.
This bit will be a result of xoring 3 bits from a number, more precisely we will xor following bits
extracting those bits is easy, for example to get a 29th bit one can do:
We tested many variants of how to efficiently write it down, but it turns out that doing just that yields best results!.
We ended up with a following code:
Similar operation can be done for 4th encoding scheme, but we will leave this as an exercise for a reader.
Even with a plethora of tools and analysis made available by other researchers its beneficial to sometimes take a deeper look into a subject.
This can potentially uncover new ways of dealing with problems, revels new clues or patterns typical to threat actor, or simply find a nice new trick.
This time we saw most of those came to life.
In addition to deep analysis of Royal Road shellcode we showed some generic methods of how to approach and/or speed up future analysis of any type of shellcode by utilizing power of scripting your disassembler and concentrating on most important parts.
More of those tips an tricks can be found in our ExtREme Malware Analysis training.
It seems that Royal Road is going to stay with us for some time, despite all of the public research and that it exploits more than year old vulnerabilities.
That being said we are looking forward to see if developers will implement any new trick or will change their approach in anyway.
It’s also possible that someone went an extra mile and create a weaponizer that will appear as Royal Road based on publicly available YARA signatures ↩︎
© 2020
Powered by Hugo, theme Anubis.
