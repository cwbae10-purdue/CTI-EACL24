 pre { background: #fff; font-size: 13px; padding: 0; }
At the beginning of April, Carbon Black Threat Research began analyzing a malware variant commonly referred to as Red Leaves, which appears to have code reuse from the PlugX family.
During the last month, this malware family has been referenced in several security blogs and government alerts.
Carbon Black is publicly providing this technical write up to assist customers, other organizations, and researchers continuing to investigate incidents related to this malware family.
Along with this report, Carbon Black is providing product specific queries, rules and scripts aimed at assisting in the detection and analysis of this malware family in the Carbon Black User Exchange.
The overall process of how the malware’s components are created on an infected system and the different points where the suite of Carbon Black products could detect the different stages of the malware are outlined in that User Exchange post.
This malware family has been observed in the wild since at least June 2016.
The malware uses a technique called DLL side loading, which is common with the PlugX family.
DLL sideloading works by using a legitimate or benign executable file to load a modified DLL.
This DLL is responsible for loading and executing an encoded or encrypted malicious data file.
The ultimate payload for this sample is a shellcode loader, which injects the Red Leaves implant, via process hollowing, into a hard coded process.
The metadata for the initial dropper file that was analyzed is listed in the information below.
The initial stage of the sample analyzed has little functionality outside of dropping or creating the malicious second stage files on the infected system.
PlugX has in the past been documented as being delivered via a self extracting (SFX) Rar executable, which acts as the first stage dropper.
Once the files have been created on disk, the dropper will execute the Obedience.exe file, starting the overall process.
A brief overview of the entire process is outlined in the below two figures and the accompanying table.
The first stage dropper will push several hard-coded values to a function, which is responsible for decoding the three embedded files.
These files comprise the second stage of the overall malware setup.
The image below displays these values being pushed (highlighted in red) as well as being labeled for clarity.
The pushed values in the above image (file offsets and sizes), are passed to a function responsible for decoding and writing the files to disk, along with the hard coded file names.
The embedded files are decoded by the function displayed in the image below.
The function will decode the first half of the file with one set of XOR keys (these instructions are highlighted in red), and the second half of the function with a different set of XOR keys (these instructions are highlighted in yellow).
The XOR key sets are derived from a 16 byte ASCII string immediately preceding the encoded data, in which every other byte is used to XOR each byte of encoded data.
The first eight bytes are used for the first half of the file and the last 8 bytes for the second half of the file.
To clarify this process, the data in the table below represents one of the encoded embedded files.
The first 16 bytes (which are in bold) are the ASCII string, from which the key sets are derived.
The first half of the file is decoded by XORing each byte of encoded data with each byte which is designated in red below.
The second half is of the file is then decoded in the same manner using the each byte, in blue, from the second half of the overall string.
The same result can be obtained by XORing each byte of the 4 byte key and then using the result to XOR each byte of encoded data, which in this specific scenario is 0x1B and clearly visible from the null areas of an executable file.
The file labeled as embed_2 is a slightly modified file that will be named StarBurn.dll.
The final file labeled as embed_3 is an encoded file that when decoded and executed will inject the Red Leaves implant into the memory of a target process.
All of these files will be be created in the current user’s Temp folder (ex.
The first stage dropper is also responsible for installing the persistence mechanism for the malware, as a shortcut named persuasion.lnk in the current user’s startup folder.
The shortcut or link file will point to the target file obedience.exe and will execute that file when the user logs into the system.
Once the benign file obedience.exe has been executed it loads several libraries, one of which is StarBurn.dll.
The below image displays the Import table from Obedience showing where the malicious GetVersion function is imported.
The StarBurn.dll is side loaded, which is a fairly common tactic often associated with the PlugX family.
Once the GetVersion function from StarBurn.dll is imported it will execute and look for the hard coded filename handkerchief.dat in the directory where StarBurn.dll is located.
The image below highlights these actions.
The handkerchief.dat file’s data is then read into memory.
The pseudo-code in the image below highlights the the next steps in the process (variables were renamed for clarity).
The StarBurn.dll function will make the address space where the handkerchief.dat data was read into memory read, write and executable (which is highlighted in the first red box).
The function will then decode the data in the same manner in which the previous embedded files were decoded, where a 16 byte ASCII string is used to derive 2 XOR key sets, which are then used to decode the first and second half of the files.
The StarBurn.dll function will then create a thread with the starting address of the decoded data, is highlighted in the second red box.
The decoded data is shellcode with an additional embedded payload.
The table below is a small excerpt of the decoded shellcode, which will load the Red Leaves implant into memory.
The shellcode will load several common libraries which will be used to inject the Red Leaves payload into memory.
The shellcode decodes (using a single byte XOR of 0x53) a portion of the implant’s configuration block, where the processname is stored that will be injected into via process hollowing.
The image below shows the code responsible for configuration decoding, highlighted in red.
The shellcode loader will then create a process in suspended state, in this case the target process was Iexplore.exe.
The image below, which has been commented for clarity, displays where the shellcode creates the suspended thread.
The Red Leaves payload will then be written to that process’ memory location and the thread is then resumed allowing the Red Leaves implant to impersonate Internet Explorer and communicate with the pre-configure C2s.
As other research reports have pointed the embedded Red Leaves implant has the MZ and PE ASCII characters from the DOS and PE headers overwritten with the values 0xFF, which are highlighted in red in the table below.
Once the Red Leaves malware is running the program will initially decode its configuration block, which is encoded using a single byte XOR (in this example the 0x53).
This functionality is highlighted in the image below.
The configuration block is 0x940 bytes in length and contains several different options related to how the malware will install itself as well as where and how it will communicate with the hard coded C2s.
The configuration block itself is a list of null terminated strings and binary values, which correspond to hard coded values.
The configuration block is detailed in the table below.
The Value section are the values present in the sample that was analyzed.
 After the configuration data has been decoded the malware will go into the main communication thread creation function, which is responsible for initiating the communications to the embedded C2s.
The connection mode value is evaluated and the malware will used the appropriate functions to either use a custom protocol or standard APIs to communicate with the C2s.
The value in this sample is 4 which will then attempt to resolve the different C2s iterating through the ports 443, 53, 80, and 995 (in that specific order).
Once a connection has been established the malware will communicate with the C2 utilizing the RC4 algorithm with the key “Lucky123”.
The malware uses a series of command Identifiers, which are parsed, and then the program will pass control to the appropriate functions to carry out commands and return the responses or data back to the C2.
The jump table responsible for evaluating commands is displayed in the image below.
The communication protocol has been well documented in other research papers, which can be reviewed for further information.
The malware itself has the following capabilities, which allow the malware to be used as an efficient Remote Access Tool (RAT).
0 Comments have been added so far
