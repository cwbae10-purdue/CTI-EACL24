Defend against threats, ensure business continuity, and implement email policies.
Protect against email, mobile, social and desktop threats.
Engage your users and turn them into a strong line of defense against phishing and other cyber attacks.
Defend against cyber criminals accessing your sensitive data and trusted accounts.
Reduce risk, control costs and improve data visibility to ensure compliance.
Protect from data loss by negligent, compromised, and malicious users.
Protect against digital security risks across web domains, social media and the deep and dark web.
Get deeper insight with on-call, personalized assistance from our expert team.
  Get real-time insight into threats that can cause data loss and brand damage.
Protect your people from email and cloud threats with an intelligent and holistic approach
Help your employees identify, resist and report attacks before the damage is done
Prevent data loss via negligent, compromised and malicious insiders by correlating content, behavior and threats
Manage risk and data retention needs with a modern compliance and archiving solution
Keep your people and their cloud apps secure by eliminating threats, avoiding data loss and mitigating compliance risk
Implement the very best security and compliance solution for your Microsoft 365 collaboration suite
Secure access to corporate resources and ensure business continuity for your remote workers
Deliver Proofpoint solutions to your customers and grow your business.
Learn about the benefits of becoming a Proofpoint Extraction Partner.
Learn about our global consulting and services partners that deliver fully managed and integrated solutions.
Learn about our relationships with industry-leading firms to help protect your people, data and brand.
Learn about the technology and alliance partners in our Social Media Protection Partner program.
Small Business Solutions for channel partners and MSPs.
Find the information you're looking for in our library of videos, data sheets, white papers and more.
Keep up with the latest news and happenings in the ever‑evolving cybersecurity landscape.
Learn about the human side of cybersecurity.
Episodes feature insights from experts and executives.
Learn about the latest security threats and how to protect your people, data, and brand.
Connect with us at events to learn how to protect your people and data from ever‑evolving threats.
Read how Proofpoint customers around the globe solve their most pressing cybersecurity challenges.
Browse our webinar library to learn about the latest threats, trends and issues in cybersecurity.
Learn about our threat operations center and read about the latest risks in our threat blog and reports.
Proofpoint is a leading cybersecurity company that protects organizations' greatest assets and biggest risks: their people.
Today’s cyber attacks target people.
Learn about our unique people-centric approach to protection.
Stand out and make a difference at one of the world's leading cybersecurity companies.
Read the latest press releases, news stories and media highlights about Proofpoint.
Access the full range of Proofpoint support services.
Proofpoint researchers are continuing to track the threat actor TA410’s use of FlowCloud, a remote access trojan (RAT).
Below is a new in-depth analysis of another version of the FlowCloud RAT, version 4.1.3.
While we do not have many campaign details or targeting information on this particular sample, this is another version of FlowCloud in the wild.
Earlier this week we provided an analysis of version 5.0.1, which was used during the targeting of critical U.S. utility providers last year.
It is currently unclear which of the versions is the “newer one” or if there are distinct variants of FlowCloud being used for different purposes.
The version we previously detailed had an older compilation date (December 15, 2018 – it is unclear whether the date is forged), but a newer internal version (5.0.1) than the sample discussed here.
One major difference between the two is that version 5.0.1 is written in C++ using extensive object-oriented programing, Boost library, and a C++ implementation of Protocol buffers—version 4.1.3 was written in C without any object-oriented techniques and used a C implementation of Protocol buffers.
Version 5.0.1 also makes use of SHA512, a modified (or broken) AES, and TEA algorithms instead of the MD5 and RC4 as described below.
In general, version 5.0.1 was a larger and more difficult malware to reverse engineer.
FlowCloud has typical RAT functionality such as access to the filesystem, processes, and services, screenshots, keylogging, command shell, and added functionality via plugins.
It also includes port mapping and Nmap port scanning to help facilitate lateral movement.
Although the additional functionality was not implemented in the analyzed sample below, there are indicators in the code and configuration data that suggests support for audio recording, clipboard stealing, and exfiltrating files based on specific search criteria such as file type and name pattern.
These might be implemented via FlowCloud’s plugin mechanism or may be present in other versions of the malware.
In this blog post we will analyze the following FlowCloud sample:
Per its metadata, it is version 4.1.3 and was compiled on March 21, 2019 (it is unclear whether the date is forged).
It was recently uploaded to VirusTotal on May 12, 2020 by a submitter from Taiwan.
At the time of research, the command and control (C&C) server (114.55.109[.
The name “FlowCloud” comes from a debugging string left in one of the earlier samples we found:
The name was also used in the configuration data of the sample analyzed for this blog post as the “product_name”:
FlowCloud makes extensive use of a data structure known as Protocol buffers (“protobufs”) in its configuration and C&C communications.
“Protocol buffers are Google's language-neutral, platform-neutral, extensible mechanism for serializing structured data – think XML, but smaller, faster, and simpler.
You define how you want your data to be structured once, then you can use special generated source code to easily write and read your structured data to and from a variety of data streams and using a variety of languages.”
As an example, in the analyzed sample, FlowCloud stores its configuration data as a 3344-byte serialized protobuf as shown in Figure 1:
Figure 1 Configuration data serialized as a protobuf
Using the Protocol buffer compiler (“protoc”), the serialized data can be deserialized into a more human-readable format as shown in Figure 2:
Figure 2 Configuration data that has been deserialized (truncated for readability)
To recover the names of the fields, the associated ProtobufCMessageDescriptor and ProtobufCFieldDescriptor structures can be identified as shown in Figure 3:
Figure 3 Configuration data’s associated ProtobufCMessageDescriptor
We have included an IDA Pro Python script on our GitHub that can be used to parse and display some of the important fields of these structures as shown in Figure 4:
Figure 4 Parsed ProtobufCMessageDescriptor and ProtobufCFieldDescriptor (truncated for readability)
The “id” numbers from the structures can be matched with the deserialized data for labeling as shown in Figure 5:
Figure 5 Labeled protobuf for configuration data (truncated for readability)
The ProtobufCMessageDescriptor structure also starts with magic bytes (e.g.
0x28aaeef9), so these can be used to identify all the protobufs compiled into the malware.
In the analyzed sample there were 78 protobufs included.
In the analyzed sample, a working directory was setup in:
The fully labeled configuration data is available on our GitHub .
Most of its fields are self-identifying and include things such as:
The configuration data is also stored as a serialized protobuf and encrypted in a “winver.dat” file.
It is encrypted using a basic XOR and addition algorithm.
We have included a Python script that can be used to decrypt this config file on our GitHub .
FlowCloud uses HTTP to download some dependencies from its C&C server (“exchange_server: exchange_server_port+1” from the config).
Figure 6 shows an example:
Figure 6 Example dependency download
The URIs are hardcoded into the sample.
The response data starts with an encrypted 16-byte header:
The header key is used with some XOR and ROR operations to decrypt the remaining bytes of the header.
After the header there is RC4 encrypted data.
The RC4 key is generated by taking a hardcoded string (e.g.
“y983nfdicu3j2dcn09wur9*^&(y4r3inf;'fdskaf'SKF”) and hashing its hex digest 1000 times with MD5.
The decrypted data starts with another 16-byte header as described above.
The data that follows this inner header is ZLIB compressed and once decompressed contains a PE file.
We have included a Python script on our GitHub that can be used to decrypt these dependencies.
C&C uses a binary protocol over TCP to “exchange_server:exchange_server_port” from the config.
An example exchange is shown in Figure 7:
Figure 7 Example C&C exchange
Both requests and responses are structured similarly.
They start with a 28-byte header called “HHDR”:
The header key is used with some XOR and ROR operations to decrypt the remaining bytes of the header.
Following “HHDR” is a 24-byte header called “HCMD”:
The header key is used with some XOR and ROR operations to decrypt the remaining bytes of the header.
Following the “HCMD” header is a 16-byte header as described above in the “Dependencies” section.
After the third header there is RC4 encrypted data.
The RC4 key for this data is generated by taking the “xchg_server_key” from the config and hashing its hex digest one time with MD5.
Once the data is decrypted there is a final 16-byte header and ZLIB compressed data (see the “Dependencies” section above).
We have included a Python script on our GitHub  that can be used to decrypt these requests or responses.
Figure 8 is an example output of our script:
Figure 8 Example parsing of a C&C request
 The decrypted data is a serialized protobuf.
For example, the names of the protobufs involved with command 1 subcommand 2 are:
This command is used to send various system information to the C&C server as shown in Figure 9:
Figure 9 Labeled protobuf for command 1 subcommand 2 (edited for privacy)
We have identified the following commands that can be executed via C&C command polls:
In addition to the C&C commands, FlowCloud has some additional functionality organized as “data exfiltration managers" that include:
These exfiltration managers run in their own execution threads and some are controlled by “policies” in the config.
They store their data in various SQLite databases and then another execution thread will eventually exfiltrate the data to the C&C server.
As an example, the “screen” exfiltration manager takes continuous screenshots according to its “screen_policy”:
Depending on its size, the data may be broken up into chunks.
The data is then compressed with ZLIB and encrypted with RC4 (uses “file_key” from config).
As described above, 16-byte encrypted headers are attached to the compressed and encrypted data.
Two additional headers are prepended to the compressed and encrypted data.
They are encrypted similarly to the 16-byte, 28-byte, and 24-byte headers above.
The first header is 96-bytes:
The second header is at least 24-bytes, but its length depends on the number of data chunks and length of a filename:
The encrypted screenshot data is then saved to a SQLite database.
In the analyzed sample this was stored in the file “data\E70EEF62”.
We have included an example of the schema used on our GitHub, but it basically consists of a “file” table to store metadata about the data to exfiltrate and a “file_data” table that stores the data.
Periodically a separate execution thread will go through the SQLite databases created by the exfiltration managers and send the data to the C&C server.
It uses the same C&C protocol as described above, but using the “file_server,” “file_server_port,” and “file_server_key” values from the config.
The Proofpoint threat research team analyzed and performed reverse engineering on a recently discovered version (4.1.3) of the FlowCloud RAT.
While the version that we analyzed is for Windows only, we believe that there may be additional variants.
One piece of evidence that may support the theory that there are additional FlowCloud variants, is the “plateform” (sic) field detailed in Figure 9 above.
This is an enumerated data type that can have the following values:
While we have only seen versions of FlowCloud for Windows, this implies there may be other implementations of FlowCloud for other operating systems.
ET and ETPRO Suricata/SNORT Signatures
2842895 - ETPRO MALWARE FlowCloud Dependency Download M1
2842896 - ETPRO MALWARE FlowCloud Dependency Download M2
2842897 - ETPRO MALWARE FlowCloud Dependency Download M3
2842898 - ETPRO MALWARE FlowCloud Dependency Download M4
Subscribe to the Proofpoint Blog
Terms and conditions
Privacy Policy
Sitemap
