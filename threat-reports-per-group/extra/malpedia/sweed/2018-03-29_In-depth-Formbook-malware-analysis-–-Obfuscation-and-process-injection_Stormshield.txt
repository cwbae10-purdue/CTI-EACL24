Formbook is a form-grabber and stealer malware written in C and x86 assembly language.
It’s a ready to sell malware, that can be used by cyber-criminals who don’t have any skill in malware development.
The sample analyzed in this blog-post has been dropped by a word document, during a mail campaign used to distribute Formbook.
We caught it thanks to Breach Fighter, our cloud-based sandboxing engine, used to analyze files received by our customers.
We wrote a previous post about a simple form-grabber malware used to hook HTTP requests made by common browsers in order to steal passwords, where we described the inline hook mechanism.
Note that several blogposts about Formbook have already been published.
The first one, from Arbor Networks (September 2017), describes some of the obfuscation methods involved with this malware.
The second one from FireEye (October 2017), gives a nice overview of the malware capabilites and also covers some of the obfuscation tricks.
Based on these articles, we decided to write a new one with a focus on:
Running the strings command on this malware doesn’t give a clue about its intent.
Indeed, all the strings used by this malware are obfuscated or encrypted.
Encrypted strings storage and encryption algorithm are explained in the section ‘Data encryption’.
The malware tries to use as less (encrypted) strings as possible.
For instance, to check for the presence of a string in memory (e.g a process’ name), rather than storing the encrypted expected string and decrypting it to perform the comparison, the malware applies a hash function on the input string and checks whether it matches the expected pre-computed hash.
The hash function used by formbook is BZip2 CRC32, applied on strings previously converted to lower-case:
In this article, each mention to a string hash refers to the BZip2 CRC32 hash of the associated string.
The malware stores encrypted buffers, “hidden” directly within the text section.
The address of each encrypted buffer is retrieved thanks to a trick commonly used by malware.
Since a call instruction pushes on the stack the address of the instruction to execute when returning from the callee, a call instruction (0xE8) with an operand of 0x00000000 leads to a jump at the address following the call.
The following ‘pop eax’ instruction can then be used to retrieve the current instruction pointer value, and thus the start of the encrypted buffer, located 2 bytes after:
Schema from Arbor Network illustrating the ‘pop eip’ trick
Arbor Networks already described this mechanism and also released a python script  which implements the decryption functions, decrypt_func1() and decrypt_func2(), used to decrypt this kind of encrypted buffers.
The decrypt_func1() function takes as argument an input buffer that is bigger than the decrypted output buffer (some bytes are used as ‘opcodes’ describing which transformation should be applied).
The decrypt_func2() function applies 2 simple transformations on the input buffer, then perform RC4 decryption using a 20 bytes key long (resulting from a SHA-1 message digest) and applies 2 more simple transformations on the input buffer.
Let’s take a look at how these 2 functions are used at the early stage of the malware, in order to decrypt an array containing many hashes, used later to perform dynamic import resolution and anti-debug / anti-sandbox tricks.
Two encrypted buffers, respectively encbuf1 and encbuf3, are given to the decrypt_func1() function, and their outputs are used to compute two SHA-1 hashes, used later as RC4 keys (rc4_key_one and rc4_key_two).
A third encrypted buffer, encbuf2, is first given to the decrypt_func1() function, and then given to the decrypt_func2() function with the  RC4 key ‘rc4_key_one’ derived previously.
The resulting buffer is decrypted with the decrypt_func2() function and the RC4 key ‘rc4_key_two’, which gives encbuf2_s3.
Finally, the SHA-1 of this buffer is computed to obtain the final RC4 key.
The following dot graph  illustrates this process.
We wrote an IDA python script, released on github, used to decrypt the array of hashes and to print the associated strings.
To find hashes related to dynamically imported functions, we modified the shellcode_hashes plugin in order to add support for BZip2 CRC32.
Since the encrypted array also contains hashes of strings used to perform anti-debug / anti-sandbox tricks, we wrote another python script used to request JSON files containing strings likely used by malware.
Since this script can be useful for analyzing other malware using strings’ hashes, we released it on github, and we’ll update it as we encounter new malwares.
Feel free to open pull requests in order to improve the JSON base of knowledge.
After executing the IDA python script, one can see that dynamic function import, anti-vm, anti-sandbox and anti-analysis trick are likely to be performed.
The full script output for this instance of formbook is available on our github respository (the format is based on this file, issued from Arbor Network’s analysis).
As you can see with CFF Explorer, the Import Directory Table (IDT) of formbook is empty.
This is generally a suspicious hint that likely suggests dynamic function importing:
Even if no dll is referenced in the import table, the Windows loader always loads ntdll.dll in the process address space.
Security solutions based on userland hooks frequently intercept functions in ntdll.dll to monitor process activity.
In order to evade monitoring, formbook maps a copy of this dll and performs many of its interactions with the operating system through this dll.
FireEye referenced this method in their article as “Lagos Island method”.
In this section, we’ll describe how formbook perform this operation.
As you may known, the view of a DLL is not the same whether it is stored on the disk or mapped in memory.
This is due to the PE file format specifications which require, for paging purposes, that each section, when mapped in memory, is guaranteed to start at a virtual address that’s a multiple of IMAGE_OPTIONAL_HEADER.SectionAlignment (0x1000 by default).
On the other hand, in the PE file, the raw data that comprises each section is guaranteed to start at a multiple of IMAGE_OPTIONAL_HEADER.FileAlignement (0x200 by default).
Also, the size of a section on the disk is always round up to the value IMAGE_OPTIONAL_HEADER.FileAlignement while the size of a section in memory theoretically doesn’t need to be round up to IMAGE_OPTIONAL_HEADER.SectionAlignment (it is in practice since the OS allocates page of 4KB).
For more information, please read A Tour of the Win32 Portable Executable File Format.
Let’s see how formbook deals with these PE specifications in order to copy and map its own version of ntdll.dll:
To retrieve the base address of ntdll, loaded by the Windows image loader, formbook uses a function that we named ‘get_module_base_address_by_hash()’.
This function iterates over each LDR_DATA_TABLE_ENTRY entry of the LIST_ENTRY ‘InMemoryOrderModuleList’ in order to compute the hash of the image name (LDR_DATA_TABLE_ENTRY.BaseDllName) and checks whether it matches the expected value, given as an argument.
If the expected checksum is found, the DLL base address is returned.
Then, it uses another function that we named ‘get_module_data_table_entry_by_base_address()’ which works as similar but returns a pointer on the LDR_DATA_TABLE_ENTRY entry when an entry with the expected base address is found.
From this entry, the full path (LDR_DATA_TABLE_ENTRY.FullDllName) of the original ntdll module can be extracted.
The next step is to perform a raw copy of ntdll from disk to memory, using the full path retrieved previously.
This is performed with the following steps:
As stated earlier, the view of a PE file is not the same on the disk and in memory.
Thus, in order to map into memory its own copy of ntdll, from the the disk copy, the following steps are performed:
From now on, the manually mapped version of ntdll is loaded in an almost similar way as the one mapped by the Windows loader, and thus can be used by formbook.
One noteworthy difference is the fact that the manually mapped dll is contained in a single committed region, whose protection is PAGE_EXECUTE_READWRITE.
The version loaded by the Windows loader is mapped in several committed regions with appropriates protections (e.g : PAGE_READONLY for the PE header, PAGE_EXECUTE_READ for .text sections, …)
In addition of using undocumented functions from the native API, formbook also uses higher level functions exported by DLLs such as kernel32.dll or user32.dll.
Theses DLLs are loaded in the process address space using the undocumented function LdrLoadDll(), from the manually mapped instance of ntdll.
The address of LdrLoadDll() is resolved dynamically using the method described in the next section.
Dynamic function importing is performed to resolve address of functions contained in both, the manually mapped version of ntdll.dll and additional DLLs loaded with LdrLoadDll().
A function that we named ‘import_func_by_hash’ is used to import functions using the address of their corresponding DLL in the process address space, and the expected function’s name hash.
The address of the function (RVA) is finally added to the DLL base address and cached by formbook in an array of imported function’s pointers.
Thus, if formbook needs to call this function a second time, it won’t have to import it again.
Once formbook has mapped its copy of ntdll, it can start to perform its malicious stuff… In this section, we will describe several methods used by formbook in order to check for:
After performing each check, a corresponding resulting byte is set within a custom structure.
Each field of this structure is then tested, in a function used to decide whether the process should stop its execution.
This function returns 0 if at least one anti-debugging or anti-analysis check identified something unusual:
Unfortunatly, when debugging this malware, it’s not sufficient to just patch the return value of this function.
Indeed, when a check fails, the malware also modifies some hashes from the encrypted hashes array so that dynamic functions import fails later.
Since formbook is a 32-bit PE, to check whether it is running in wow64 compatibility mode (i.e 32-bit PE running on a 64-bit Windows OS), it checks whether the full path of ntdll.dll contains ‘wow64’.
When PE files are running in wow64 mode, a specific 32-bit version of ntdll is mapped with the particularity that each syscall routine ends with a call to [fs:0xc0] (It’s not the case anymore on Windows 10, but [fs:0xc0] is still usable for compatibility reasons).
This is actually a call to the address contained in TEB structure’s field ‘Wow32Reserved’, which result in a routine located in wow64cpu.dll.
This routine is used to switch from 32-bit to 64-bit native code by performing a jump instruction with the segment selector 0x33.
A method for tracing system calls performed by PE running in wow64 mode consists in overriding the ‘Wow32Reserved field’ to setup a hook mechanism.
It is for instance used by Stealth64 OllyDbg plugin.
The idea is to replace the field ‘WoW32Reserved’ with the address of custom section of code used to intercept syscalls.
To check if a hook is setup, formbook checks whether the field ‘Wow32Reserved’ points to a section of code belonging to a PE64 DLL (i.e wow64cpu.dll), by performing the following step:
Formbook checks if the module SbieDll.dll is loaded within its address space.
To do so, it uses a function that we named ‘get_dll_base_address_by_hash()’, described earlier.
If the expected checksum is found (0xe11da208 for SbieDll.dll), the function returns the base address of this module and a flag related to this check is set.
In order to check for blacklisted running processes, formbook calls NtQuerySystemInformation() with the class ‘SystemProcessInformation’.
It then iterates over each SYSTEM_PROCESS_INFORMATION entry in order to compute the hash of the field ‘ImageName’.
It then checks within the array of encrypted hash (from offset 79 to 98) if the computed hash is blacklisted.
From the list of decrypted hashes, we can view that it consists of the following image names:
Formbook checks whether it is currently being debugged, by calling NtQuerySystemInformation() with 2 different classes:
The ‘BeingDebugged’ field from the PEB structure is also used later by formbook, to break from an infinite loop as soon as a userland debugger is attached.
Formbook checks whether its own image name (BaseDllName) ends with a string whose hash equals 0x7c81c71d.
This check is probably targeting a specific sandbox environment that change PE files’ image name before execution.
Formbook checks whether one of its loaded module is located within one of 7 blacklisted directories.
To do so, it iterates over the LIST_ENTRY ‘InMemoryOrderModuleList’, extracts the full path of each module (FullDllName) and computes the hash of each directory that is part of the full path.
Each hash is then checked within the array of encrypted hashes (from offset 99 to 105).
From the list of decrypted hashes we can view that it is designed to detect sandboxed environments:
Formbook retrieves the username from its environment using RtlQueryEnvironmentVariable_U() with the variable name ‘USERNAME’.
It then checks, within the array of encrypted hash (from offset 106 to 112), if the username contains as a substring a blacklisted usernames.
From the list of decrypted hashes , we can view that it is also designed to detect sandboxed environments:
In this section, we’ll describe how formbook performs its process injection to migrate in a process whose image base belongs to Microsoft.
For simplification issues, in this
section, we’ll consider that formbook runs on a 32-bit Windows version.
Formbook can migrate from a 32-bit process running in wow64 mode to a native 64-bit process, but this implies a lot of patches on the .text section.
The previous form-grabber malware that we analyzed used a well known method to inject targeted processes using WriteProcessMemory() and CreateRemoteThread().
Formbook uses another method, less common, which can be summarize in 3 stages:
The main advantages of this method are that no new thread is created within explorer’s process and the parent process of the suspended created process is explorer.
Formbook will perform several operations on explorer’s process, such as mapping sections of code within this process address space or suspending / resuming its main thread.
Since explorer’s process runs with the same user account as the currently logged-on user, formbook process doesn’t need additional privileges to perform debugging like operations.
Indeed, for debugging non-system processes, it is not necessary to grant or enable SeDebugPrivilege.
However, the malware author doesn’t seem to be aware of this and formbook updates its privileges in order to enable ‘SeDebugPrivilege’.
To do so, it uses NtOpenProcessToken() to get an handle on its own process, and then uses ConvertSidToSidW() and NtAdjustTokenPrivileges().
The malware doesn’t check if its privileges have successfully been updated, thus the execution continues in any case.
Formbook maps a copy of its running process, within its own address space, using the following steps:
As an anti-forensic technique, the header of the new mapped section is overridden with the SHA-1 of a random 32-bit integer.
Thus, formbook’s PE header won’t appear in clear within explorer’s neither in the hollowed process’ address space, when it will be mapped in these processes.
However, this in an issue for a function that we called ‘get_base_address_from_text()’, which retrieves the base address of formbook, by trying to find the string ‘This program cannot’ in memory, followed by the MZ header.
Thus, the random value is saved by patching an instruction from the ‘get_base_address_from_text()’ function, so that it takes another path, used to find the PE base address, by searching for the expected SHA-1 in memory.
In order to apply this patch to the ‘get_base_address_from_text()’ function, a loop is performed on the whole mapped section using the ‘egg hunting’ technique to find the sequence of bytes “40 41 49 48 B8 88”:
We can find these instructions from the function ‘get_base_address_from_text()’, before being patched:
Since Hex-Rays decompiler cannot guess that the bytecode will be patched, its evaluates the cmp instruction as always true and thus doesn’t evaluate the false branch:
After applying its patches, formbook tries to find explore.exe’s pid and main thread id, using the same method as for checking for blacklisted running processes.
It uses NtQuerySystemInformation() with the class ‘SystemProcessInformation’ and iterates over each SYSTEM_PROCESS_INFORMATION entry in order to compute the hash of the process image name, up to finding the one related to ‘explorer.exe’.
After retreiving explore.exe’s pid, formbook retrieves an handle on this process, using NtOpenProcess() with the following desired access:
Then it is able to map its patched section of code, within explorer.exe address space.
This new mapped section will be used to execute formbook code within explorer’s main thread, as well as to provide a shared buffer between formbook and explorer processes.
An handle on explorer’s  main thread is retrieved using NtOpenThread() with the following desired access:
Thus, formbook is now able to suspend explorer.exe’s main thread using NtSuspendThread(), and to retrieve its instruction pointer within the CONTEXT structure using NtGetContextThread().
Then, another patch is applied on formbook’s section of code that will be executed by explorer.
The unpatched instructions look as following:
The patch consists in replacing the 0x88888888 immediate value by the Eip field extracted from the CONTEXT structure previously.
This is used to save explorer.exe instruction pointer in order to restore it at the end of formbook code execution.
As you can see, the call to ‘formbook_main_explorer32_hijacked()’, is surrounded by a pusha and popa instructions so that explorer’s process retrieves its registers values as if its thread had never been hijacked.
When the return instruction is executed, explorer’s main thread will continue its execution as if it had never been hijacked.
By attaching to explorer.exe and searching for this section of code within its process address space we can see the patch:
After applying the patch, a call to NtSetContextThread() is used to update explorer’s main thread instruction pointer which is now hijacked, and points to formbook’s code within explorer.
At this point, the thread is still suspended.
Then an APC is injected by calling NtQueueApcThread(), with an entry point to the user APC routine pointing on the pusha instruction, just before the call to formbook_main_explorer32_hijacked().
This is quite elegant since the same section of code is used by both context calls, one from the hijacked thread and another from the injected APC routine.
Finally, a call to NtResumeThread() is performed.
Before resuming hijacked explorer’s main thread, the kernel first pops and executes each APCs from the thread’s APC queue.
Finally, the hijacked explorer’s main thread is executed and a second call to formbook_main_explorer32_hijacked() is performed.
Unlike within formbook process address space, the hijacked thread of explorer doesn’t map a copy of ntdll and doesn’t perform any anti-debug trick.
The full path of ntdll.dll is retrieved using the method described previously (c.f: Retreiving the original ntdll.dll full path), and is used as the ‘System32’ or ‘SysWOW64’ source directory to open a randomly chosen windows executable, from a list of 39 entries.
The windows executable list is stored in an encrypted buffer whose RC4 key is derived from the SHA-1 of the following 16 bytes buffer: “00 00 01 01 00 00 01 00 01 00 01 00 00 00 00 00”:
As explained by FireEye, this buffer is actually the same as the result of the anti-analysis tests placed into a 16-bytes array used to decide whether formbook’s process should continue its execution.
After decryption of an encrypted buffer, one can see the list of 39 windows executable (from offset 3 to 41) that can be used by formbook to migrate itself:
The full list of windows executable used to perform process hollowing is available here.
The chosen executable image base is then used to create a suspended process with a call to the undocumented function CreateProcessInternalW(), exported by kernel32.dll.
It is interesting to notice that, for this function especially, the associated decrypted hash (0xad0121e0) is modified with a simple subtraction before trying to perform the dynamic import:
The following information related to the newly created process are copied in a memory area shared between explorer and formbook process:
This shared memory area is contained in the same section as formbook image mapped into explorer.
Thus, in formbook process address space, they have the same view base address resulting from NtMapViewOfSection(), and thus have the same page protection (PAGE_EXECUTE_READWRITE).
Now, either the injected APC or the hijacked thread have finished their work.
Note that if the APC is successfully executing within explorer, a flag is set within the shared buffer that will be tested by the hijacked thread, to avoid creating a second suspended process.
Thus, we can conclude that hijacking explorer’s main thread is useless if the APC is always successfully executed.
Just after its call to NtResumeThread(), formbook needs to wait for the suspended process to be created.
Thus, it sleeps using NtDelayExecution() and then tries to read from the shared memory area the information filled by explorer’s injected APC or explorer’s hijacked thread.
If the newly created process’ pid, main thread id, image base full path and base address are successfully read and have non-null values, formbook will be able to perform its process hollowing.
An handle on the targeted process and targeted thread are retrieved using NtOpenProcess() and NtOpenThread().
Based on the retrieved image base full path, formbook maps a raw copy of the PE file from the disk image base.
Thus, it is able to parse the PE header and to extract the address of entry point of the suspended process.
Now, formbook will map itself within this process, such as it did previously to map itself within explorer’s address space.
Then, it will override the first instructions of the suspended process entry point, in order to perform a call to a function that calls ‘formbook_main_migrated()’.
The patch is built from stack-based operation, and looks as following:
The operand of the call is then fixed with the relative offset to a formbook’s instruction which calls ‘formbook_main_migrated()’.
Let’s take a look at a real example, where the randomly chosen process is ‘wuauclt.exe’:
With WinDbg and CFF explorer we can see that:
By adding the address following the call instruction from wuauclt’s patched entry point (0x60000+0x5891+10), to the operand of the call instruction (0x00115ea2) we can see that the destination of the call is formbook’s instruction used to call ‘formbook_main_migrated()’:
Finally, after patching the suspended process entry point, a call to NtResumeThread() is performed, and formbook starts the execution of ‘formbook_main_migrated()’ within the migrated process.
The original formbook process can thus stop its execution by calling ExitProcess().
Once formbook has migrated within the newly created windows process, it can finally target applications containing sensitive information.
Within an infinite loop (while a debugger isn’t attached), it tries to find process name’ hashes matching in the array of encrypted hashes (from offset 120 to 211).
From the list of decrypted hashes, we can view that it consists of different kind of applications such as web-browsers, mail programs, instant messaging applications, FTP clients or even Skype:
We haven’t yet analyzed in-depth this part of the malware, but the code injection techniques looks similar to what we explained in this post.
Formbook maps itself within the targeted processes and uses thread hijacking and APC injection to execute different kind of routines, according to the targeted process.
