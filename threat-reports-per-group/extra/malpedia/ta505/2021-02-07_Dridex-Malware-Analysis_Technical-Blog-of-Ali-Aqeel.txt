Dridex “also know as Bugat and Cridex” is a form of malware banking trojan and infostealer that operated by criminal group referred to as “Indrik Spider”.
Dridex specializes in stealing banking credentials via systems that utilizes macros from Microsoft office products like Word and Excel.
In previous recoded incident the threat actors have used Dridex to hit high value targets with ransomware [2].
In this post, presenting reverse engineering malware of the recent Dridex sample that has been found in the wild earlier this February.
The analysis highlights the techniques and codes used by the threat actor; and the method used to analyze this sample and extract hidden IOC and files that has not been detected by sandbox.
Note that multiple labs got different artifacts and indicators so this work is almost a contribution to others security labs and researchers.
This malware has two stages, the first one is an Excel file that has embedded VBA macro which infect the system with a DLL file that runs as a process in the second stage.
As what appear to look like an invoice delivered via email at the first day of the month is a malicious spreadsheet.
The XLSM extension is indication that M stands for Macro and the code only runs when macro feature is activated and clicking on the sheet!
What looks like cell with number are just images linked to the macro.
There’re three hidden sheets and locked macro!
Apparently locked doesn’t mean password protected, it means locked!
And can’t be extracted and reused in new excel for this case in particular.
To debug this sample require two steps:
First: extract the sample and locate the malicious file that has the macro using oledump.py.
Identifying the macro is located at the fifth stream which is a VBA code.
Below is the extracted code
Second: Unlock the document by using EvilClippy tool which removes the malicious macro.
Open the new version and create new macro and paste the above VBA code.
Previous incidents involve Dridex also notice the use of EvilClippy use
Before debugging the code, the main sheet and the three hidden ones got some characters white colored spread among cells by 7×7000 size.
After a bit of cleaning they appear be random, but not encoded.
Below are the sheet characters.
When debugging the code it appears to be those random characters spread on sheet cell start forming three arrays.
When reading it top to bottom one character at the time it appears to be URLs.
After complete running the code it generates over a 100 URL, all the URLs are in Appendix – A
After re-debugging multiple times there appears to be two random IOCs generate.
A URL to connect download site and the DLL file name.
What’s interesting is that some!
Of the generated URLs are not from the list in Appendix -A and that is what Dridex is all about.
Below is three samples of random generated IOCs.
Further IOC are found in VT.
Finally, the end of this stage is creating a process that use Regsvr23.exe to run the create DLL.
The third hidden sheet contains the end/exit function of the VBA.
There’s temporary file generated in the %TEMP% folder has a cache version of the macro.
Other network and host-based IOCs are found on VT.
Up the time writing this post 13/69 of VT engines has detected this file as malicious
This binary never been seen before the incident and the compiled time from 2009.
Other than that there are couple of indicators this file is suspicious like the file size compared to strings, imported and exported sections, and resources section
When running this binary on IDA it seem to be too much gray and less code and resources.
The binary isn’t detected to be packed in Detect it Easy or PEiD, but there’s high Entropy.
After few rounds on x32dbg it appears to be this binary is using DLL self-injection technique.
To put simply there is a hidden code that overwrite the original PE file with new file during runtime.
This technique requires to allocate memory space to the hidden code first then extract it the code in the region of the memory.
The overwritten happens on memory during runtime and to make it happen it requires two setting two breakpoint (VirtualProtect and VirtualAlloc).
Once hitting certain space memory it’s possible to extract.
After few runs and reaching the EntryPoint on x32dbg and being on the right module and setting, it is time to set the breakpoint
After hitting Run (F9) few time you reach to a <VirtualAlloc> breakpoint which by checking the EAX register appears to freed up some space
Before running to the next breakpoint let’s make sure what has been allocated by putting breakpoint to return (ret) or just Run Until Return [Figure 18].
return from this function it appears to be some random data has filled up EAX [Figure 19].
When Follow in Memory, it appears that memory space has Execute, Read, and Write which is a sign of hidden code to be executed in the next steps
After another Run [F9] and stop at a second <VirtualAlloc> breakpoint and free up space in memory and by checking EAX dumped value it appears to have nothing.
The memory space of the new allocated is also with ERW privileges.
It’s the same as the previous stop as the <VirtualAlloc> but this time different memory place and different gibberish values
The next Run (F9) would be stop at <VirtualProtect> when dumping EAX register, there appears to be something close to MZ header!
By checking the dump values there are some normal ASCII characters that resembles executable binary.
Reaching this point means the next Run (F9) will be overwriting the original PE (Libeay32.dll), in this case, with new file
It’s possible to dump memory location from x32dbg Memory Map, but choosing alternatives is sometimes better like using ProcessHacker.
When running ProcessHacker in Administrative mode > selecting the running process inside x32dbg > open Properties > Memory tap > Locate the same memory (0x24f0000) “which is dynamic value different on each run” > Right click and save
When loading this dumped binary in PE-bear, it appears to not having any Imports.
Which is normal because it’s been dumped from memory, but it requires fix get things right
The fix requires matching the ‘Raw Addresses’ to match ‘Virtual Addresses’ of this binary.
When values matched the Imports section is fixed and shows DLL values
Compared with [Figure 12] the new dumped file seems to be entirely different binary with new compile time by Sep 2020 unlike the original PE which show compilation on 2009
DO NOT click at any URL
[2] Big Game Hunting: The Evolution of INDRIK SPIDER From Dridex Wire Fraud to BitPaymer Targeted Ransomware, https://www.crowdstrike.com/blog/big-game-hunting-the-evolution-of-indrik-spider-from-dridex-wire-fraud-to-bitpaymer-targeted-ransomware/
[3] Excel file sample, https://app.any.run/tasks/8e693e74-befe-4c01-ad8e-aed066254d5b/
[4] DLL file sample, https://app.any.run/tasks/0a690f3a-3bfa-4490-9022-2057163ea5cc/
[5] EvilClippy Github repository, https://github.com/outflanknl/EvilClippy
[6] Excel File VT, https://www.virustotal.com/gui/file/b721618810b06ed4089d1469fc5c5b37be1a907fc1ae14222f913c6e2b0001c2/detection
[7] DLL File VT, https://www.virustotal.com/gui/file/26a659ec56c7bd7b83a2f968626c1524bda829e0fefff37ecf4c4fb55ad158e3/detection
[8] Ten process injection techniques: A technical survey of common and trending process injection techniques, https://www.elastic.co/blog/ten-process-injection-techniques-technical-survey-common-and-trending-process
