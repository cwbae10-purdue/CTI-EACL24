As a reverse engineer and malware researcher, the tools I use are super important for me.
I have invested hours and hours in creating the best malware analysis environment for myself and chose the best tools for me and my needs.
For the last two years, radare2 is my go-to tool for a lot of reverse-engineering tasks such as automating RE related work, scripting, CTFing, exploitation and more.
That said, I almost never used radare2 for malware analysis, or more accurately, for analysis of malware for Windows.
The main reason was that radare2 command-line interface felt too clumsy, complicated and an over-kill.
IDA Pro was simply better for these tasks, a quick inspection of functions, data structures, renaming, commenting, et cetera.
It felt more intuitive for me and that what I was searching for while doing malware analysis.
Along the years, the radare2 community had tried to develop many different graphic-interfaces for radare2.
None of them came even close to Cutter.
Cutter is a QT C++ based GUI for radare2.
In my opinion, it is the GUI that radare2 deserves.
To quote from Cutterâ€™s Github page:
Cutter is not aimed at existing radare2 users.
It instead focuses on those whose are not yet radare2 users because of the learning curve, because they donâ€™t like CLI applications or because of the difficultyâ€¦
Cutter is a young project, only one-year-old, and it is the official GUI of radare2 (the first and only GUI to be announced â€œofficialâ€).
Cutter is a cross-platform GUI that aims to export radare2â€™s plenty of functionality into a user-friendly and modern GUI.
In this post, Iâ€™ll show you some of Cutterâ€™s features and how I work with it.
To be honest, Cutter is intuitive so you probably wonâ€™t need me to show you around, but just in case.
Cutter is available for all platforms (Linux, OS X, Windows).
You can download the latest releaseÂ here.
If you are using Linux, the fastest way to use Cutter is to use the AppImage file.
If you want to use the newest version available, with new features and bug fixes, you should build Cutter from source by yourself.
It isnâ€™t a complicated task and it is the version I use.
First, you must clone the repository:
If any of those do not work, check the more detailed instruction pageÂ here.
Dropshot, also known as StoneDrill, is a wiper malware associated with the APT33 group which targeted mostly organizations in Saudi Arabia.
Dropshot is a sophisticated malware sample, that employed advanced anti-emulation techniques and has a lot of interesting functionalities.
The malware is most likely related to the infamous Shamoon malware.
Dropshot was analyzed thoroughly by KasperskyÂ and later on by FireEye.
In this article, weâ€™ll focus on analyzing how Dropshot decrypted the strings inside it in order to evade analysis.
In part 2 of this article, which will be published soon, weâ€™ll focus on decrypting the encrypted resource of Dropshot which contains the actual payload of the malware.
The Dropshot sample can be downloaded from hereÂ (password: infected).
I suggest you star (â˜…) the repository to get updates on more radare2 tutorialsÂ ğŸ™‚
Please, be careful when using this sample.
It is a real malware, and more than that, a wiper!
Since weâ€™ll analyze Dropshot statically, you can use a Linux machine, as I did.
Who said radare2 doesnâ€™t have a decent GUI?
| Decrypting the encrypted strings of APT33â€™s Dropshot malware using Cutter (@r2gui) and @radareorgâ€˜s Python API.
Check it out @ https://t.co/u50oaVYsOU pic.twitter.com/8loEAG07IW
â€” Itay Cohen (@megabeets_) May 21, 2018
Now that we have Cutter installed, we are set to go and startÂ our analysis.
Open Cutter by double-clicking on its Icon or typing ./CutterÂ in the command line.
Under the â€œOpen Fileâ€ tab select a new file and press â€œopenâ€.
After opening the file, we landed on the â€œLoad Optionsâ€ window of Cutter.
This is an intuitive dialog where we can tell radare2Â how to analyze the file.
By expanding the â€œAdvanced optionsâ€, we can set a specific Architecture, a CPU, choose a file format and many more.
In order to analyze this sample more accurately, I chose to modify a more advanced option.
By moving the Analysis slider we can modify the level of Analysis.
Weâ€™ll move it to the right in order to choose the Advanced analysis mode.
Then, disable the auto-renamingÂ of functions by removing the check from â€œAutorename functions based on context (aan)â€.
I chose to disable aanÂ since in this sample, the algorithm behind aanÂ is renaming some functions with confusing names.
After clicking â€œOKâ€ weâ€™ll see the main window of Cutter, the dashboard.
In your case, it might look different than mine but it can be easily configured.
For example, by clicking â€œView -> Preferencesâ€ you will be able to change the theme colors and to configure the disassembly.
The widgets are very flexible and can be located almost anywhere on the screen.
You can also add more widgets to the screen by choosing the desired widget from the â€œWindowâ€ menu item.
Take a few minutes to play with the environment since weâ€™ll not dive deep into the interface.
When analyzing a malware sample, I usually start by statically examining the binary.
A basic static analysis can sometimes confirm whether a file is malicious, provide information about its functionality, and help us understand what we are facing.
Although the basicÂ static analysis is straightforward and can be quick, itâ€™s largely ineffective against sophisticated malware.
So before reading any assembly, letâ€™s have a look around on some widgets.
Starting with the Strings widget, we are not seeing anything too interesting.
Some strings might indicate names of files to be dropped â€“ like â€œC-Dlt-C-Org-T.vbsâ€ and â€œC-Dlt-C-Trsh-T.tmpâ€, others look unique but not telling us much, for example, â€œHello dearâ€.
We can also see some API functions and library strings we are familiar with, but thereâ€™s no â€œsmoking gunâ€.
Another attribute that is worth checking is the fileâ€™s entropy.
What is an entropy of a binary file?
Iâ€™ll use a nice quote which is originated from this page (in Russian, I have no idea what is written here) but was taken by me from this great article about entropy.
Oh, whatâ€™s the way this word hasnâ€™t been mocked in thermodynamics!
The measure of order in the system, the measure of energy dissipating and whatâ€™s not!
Without any doubt, a real physicist will be sick of our definition while a real mathematician is going to be outraged.
Nevertheless, as true dilettantes, letâ€™s define the word â€œentropyâ€ as a measure of the efficiency of information storage.
Simply put,Â entropy (in our case) is the measurement of randomness in a given set of values (data).
The Entropy of a file (or data)Â is calculated similarly in different programs.
Usually, it is a number between 0.0 to 8.0.
The value of entropy is a reliable sign that the file is packed, compressed or contains packed or compressedÂ data inside.
A packed binary will probably have high entropy value.
Some would say that 6.0 is high enough, some will say that 7.0 and above.
I prefer to be somewhere in the middle and to treat 6.8 as good indicator that the binary or some of its components are compressed or packed.
We can easily see the calculated entropy of Dropshot by looking at Cutterâ€™s Dashboard widget:
As you can see, our file has an entropy of 7.1 which is a very good indication of a compressed\packed data.
To be more specific, we can see in the Sections widget the entropy of each section:

Look how high the entropy of .rsrcÂ section is.
Remember that the highest possible entropy value is 8.0.
No doubt, we have an interesting data in this section.
Weâ€™ll get to that later in the 2nd part of this series.
While I was going through Dropshot code, I found that it is using a rather not-too-complicated method to decrypt its embedded strings (well, most of them).
This function stood up in my analysis mainly because it was called many many times in the code and was used mainly before LoadLibraryAÂ and GetProcAddress.
So it looked to me as a technique to load libraries and functions dynamically in order to complicate analysis.
A very popular approach among malware authors.
The aim of this article is not to understand every component of the malware, but to get familiar with Cutter, scripting with radare2, and how both can be used by malware researchers.
Thus, (sadly) I wonâ€™t explain every step I took to find the decryption function.
As said before, spotting the decryption function was done thanks to its popularity and its cruciality to the programâ€™s flow.
If you want to give it a shot and try to find it by yourself â€” this is the time.
Whether you found it or were too lazy to even search, hereâ€™s the answer â€” the decryption function is located at 0x4012a0Â and appears to take two parameters.
In the next screenshot, weâ€™ll see a function which is using the decryption function.
The demonstrated function above (0x4017a0) is passing two parameters into our decryption function (0x4012a0).
The first argument is 0xbÂ (Decimal: 11) and the second argument is an address at 0x41b8cc.
This is the time to rename our strings decryption function in order to ease our analysis.
It can be easily done by clicking on fcn.004012a0Â and pressingÂ Shift + NÂ or by right-clicking and choosing â€œRenameÂ fcn.004012a0â€œ.
Enter the new name andÂ press OK.
I chose to call it strings_decrypter.
Next, we can see that the output of strings_decrypterÂ (eax) isÂ being pushed to another function at 0x4013b0Â in addition to another argument, 1.
Letâ€™s have a look at this function:
The function is taking the right branch if the argument passed to it is 0 (i.e EAX == 0) and the left branch if it is not.
Either way, it will call LoadLibraryAÂ with a string that would be decrypted using our beloved decryption function.
Iâ€™ll spoil it for you â€” the function would load ntdll.dllÂ on the right branch and kernel32.dllÂ on the left.
Simply put, the function is loading the required library in order to use a function from it.
Iâ€™ll rename this function to load_ntdll_or_kernel32.
Now letâ€™s get back to the previous function and continue to examine it.
After choosing loading eitherÂ ntdll.dllÂ or kernel32.dll, the function callsÂ GetProcAddress with a handle to the loaded library and the string thatÂ it decrypted at the beginning.
We can be sure that this string is an exported API function of kernel32.dll.
A few instructions later we can see that the referenced API function is being called.
We donâ€™t have any idea which API function is being called.
Thatâ€™s why we need to understand how strings_decrypterÂ is working and what is each parameter that is being passed to it.
We talked about this function constantly but we didnâ€™t see it yet.
Hereâ€™s the graph of the function as created by Cutter:
So, what do we have here?
We obviously wonâ€™t go over it step by step, but we need to, and will, understand the general idea.
We already know that this function receives two arguments.
The first one is an address and the second is a number.
The address argument is held by a variable named arg_8h, the integer is stored at arg_ch.
At the first block, starting atÂ 0x4012a0, we can see that a buffer at the size of arg_ch+1 is allocated by VirtualAlloc.
Then the address to the allocated buffer is assigned to local_8h.
We can rename it to bufferÂ by clicking on its name and pressing Shift+N.
This can also be done using the right-click context menu.
After that, we can see that zero is assigned to local_4h.
The next block is a starting of a loop.
We can see that the integer stored at arg_chÂ is assigned to edx which in turn is compared with local_4h.
We can understand now that arg_chÂ is some kind of length or size and local_4hÂ is a loop index.
Letâ€™s rename both to lengthÂ and index.
Now that we know the purpose of one argument of the two and the purpose of the two local variables, we need to understand what is in the address that is passed via arg_8h.
In our example, we saw the valueÂ 0x41b8ccÂ being passed to our strings_decrypter function.
Letâ€™s go to the Hexdump widget and seek to this address.
Just type this address in the upper textbox in order to seek a flag or an address.
We can see that this is a half-word (2 bytes) array of integers that starts fromÂ 0x41b8ccÂ and ends atÂ 0x0041b8e1.
Using another great feature from Cutter (at the right side of the screen), we can generate a C array of half-words:
Thatâ€™s a really great feature, right?!
Cutter can generate different types of arrays to ease scripting tasks.
This array will help us later to write the decryption script.
For now, letâ€™s continue to figure out how strings_decrypterÂ works.
Entering the loop, we can see that eaxÂ will hold the indexÂ and ecx will hold the aforementioned array.
Then, a byte from [ecx + eax*2]Â is moved to edx.
Basically,Â edxÂ now equals to half_word_array[index*2].
Next, our buffer is moved to eax which in turn is being added with the value of index, setting eaxÂ to a specific offset in the allocated buffer.
Then, at 0x004012eb,Â we can see that a byte is moved to cl.
This byte is taken from index [edx]Â of a pre-defined string.
Double-clicking the string will reveal us the full string â€” AaCcdDeFfGhiKLlMmnNoOpPrRsSTtUuVvwWxyZz32.\EbgjHI _YQB:"/@\x0a\x0d\x1a.
Immediately after that, the byte fromÂ clÂ is copied into the specific index in our buffer.
The loop continuesÂ lengthÂ times.
After all this mess we can say that the array which is passed to this function,Â arg_8h, is simply anÂ array of offsets in this string and lengthÂ is the length of the string to be built.
This is how Dropshot builds its strings, by passing the offsets array and the stringâ€™s length.
Letâ€™s confirm this claim by testing it with Python.
This is where another great feature of Cutter is being used, an integratedÂ Jupyter notebook.
We donâ€™t need to open any external Python shell, we can use Cutterâ€™s Jupyter widget.
Oh, I love this feature!
So letâ€™s write a quick proof of concept to confirm that this is really how this decryption function works.
Hereâ€™s the quick POC in python:
And letâ€™s run it in Jupyter:
We can see that we successfully decrypted the string and got â€œDeleteFileWâ€ which is an API function.
So now we can feel confident to rename the last argument, arg_8h, to â€œoffsets_arrayâ€.
Now that we figured out how strings_decrypterÂ is working, and even decrypted one string, we can see where else this function is being called and decrypt all the other strings.
To see the cross-references to strings_decypter,Â click on its name and press X on the keyboard.
This will open the xrefs window.
Cutter will also show us a preview of each reference to this function which makes the task of inspecting xrefs much easier.
We can see dozens of calls to strings_decrypter, too much for a manual decryption.
That is where the power of radare2 and Cutter scripting will come handy!
Scripting radare2 is really easy thanks to r2pipe.
It is the best programming interface for radare2.
The r2pipe APIs are based on a single r2 primitive found behindÂ r_core_cmd_str()Â which is a function that accepts a string parameter describing the r2 command to run and returns a string with the result.
r2pipe supports many programming languages includingÂ Python,Â NodeJS,Â Rust,Â C, and others.
Lucky us, Cutter is coming with the python bindings of r2pipeÂ integrated into its Jupyter component.
Weâ€™ll write an r2pipe script that will do the following:
* Note that the following script requires an understanding of radare2 commands.
Most of the commands Iâ€™ll use here explained in my previous articles on my series of articles: â€œA journey into Radare 2â€.
Make sure to check it out!
The first item on our list is to define the addresses of the components we have already detected: the decryption table and the decryption function.
Next, we need to analyze the binary so radare2 will detect the xrefs and functions.
aaÂ is a basic analysis command of radare2.
cutter.cmdÂ is a function that receives a radare2 command and returns its output, if thereâ€™s any output at all.
Letâ€™s move on and dump the content of the decryption_table to a variable.
pxjÂ is used toÂ print hexdump, theÂ j suffix can be used in most of the radare2 commands to get a JSON output.
cutter.cmdjÂ will parse the JSON output for us.
So basically in this piece of code, we are telling radare2 to take decryption_table_lenÂ bytes from (@) the address of decryption_table.
Now we have all the data we need in order to start iterate over the references to the decryption function.
Using a Python forÂ loop, we will iterate over the output of axtj.
This command stands forÂ analyzeÂ xrefsÂ to and it is being used to list all the data and codeÂ references to a specific address.
In our case, this address will be our decryption function.
The first thing that we will do in each iteration is to parse the two arguments that are passed to the decryption function.
These will be the offset array and the length of the string to be decrypted.
Weâ€™ll parse the arguments using pdj -2 @ <some xref address>.
pdjÂ stands forÂ printÂ disassembly.
Passing -2Â to pdjÂ is telling radare2 to print 2 instructionsÂ before the given address.
We assume that these two arguments will be passed to the function right before it is being called by the program.
Now for the fun part, decrypting the string.
Since we already did a POC of it, we know how the decryption works.
This will be easy to implement using a for loop:
Now decypted_stringÂ is holding the, well, the decrypted string.
All we left to do is to print it to the console and add inline-comments in each call.
The commandÂ CCÂ will be used to add the comments.
Now we can combine it all into one script:
Now we can paste the script to the Jupyter notebook inside Cutter and execute it.
A second after, we can take a look at the Comments widget and see that our script worked and updated the comments:
We can also see these comments inline in the disassembly:
We did it, we decrypted the encrypted strings and added inline comments to ease the analysis process.
The final script can be found here.
Here comes to an end the first part of this article about decrypting Dropshot with Cutter and r2pipe.
We got familiar with Cutter, radare2 GUI, and wrote a decryption script in r2pipeâ€™s Python binding.
We also analyzed some components of APT33â€™s Dropshot, an advanced malware.
The next part will be shorter and in it, weâ€™ll see how to decrypt an encrypted resource inside Dropshot.
This resource is the actual payload of Dropshot.
As always, please postÂ comments to this post or message meÂ privatelyÂ if something is wrong, not accurate, needs further explanation or you simply donâ€™t get it.
Donâ€™t hesitate to share your thoughts with me.
Subscribe on the left if you want to get the next articles straight in your inbox.
Nice write up, not used cutter before, off to check it out now!
I look forward for the part 2!
Your blog is one of the best place to learn r2.
Im running cutter on macOS, and for some reason the assembly and graph arenâ€™t showing up in the interface.
Any idea what could cause this?
Make sure that the â€œDisassemblyâ€ and â€œGraphâ€ widgets are checked in the Windows menu (see upper toolbar).
Also, try double-clicking on a function in the Functions widget and see if any of these widgets is opened.
If all fails â€“ please open an issue on Github.
All the functions are showing except the one at 0x4012a0.
Thanks a lot for sharing your knowledge!!
This may be a dumb question.
But could you please tell me how you found that `0x41b8cc` is a half-word (2 bytes) array of integers and ends at `0x0041b8e1`.
Everything else was clear to me.
Thanks for the excellent resource.
ğŸ™‚
Honestly, in such cases, having experience is coming handy.
For example, you can see that from `0x41b8cc` you have bytes which are separated by `0x00` in a pattern like this: `??00??00??00?
After 11 times of `?
?00` you see that the pattern stops, and then you have `0000` which usually indicates end of structure (array, strings, etc).
Also, remember that the function received an argument which was `0xb` (decimal: 11)?
This is another indication that we have an array of 11 items since this argument was used as an index\counter in a loop.
Ooh, is it just because of the other argument, i.e the length?
Because in the final script, we donâ€™t care about the end of the offset_array and directly access the number at the offset of i*2 where is the other argument passed to the string_decyptor function.
Am I on the right track?
Hi,
First off thanks for these great resources!
Iâ€™ve been trying to expand my RE toolset from IDA/ghidra/gdb and have been really enjoying these blog posts.
I was wondering if there were any resources you could point to for installing the cutter-jupyter plugin?
Iâ€™ve tried symlinking/copying it into the plugin directory but the jupyter plugin fails everytime!
Its failing in â€œshiboken2â€ with the initialisation raising an unreported exceptionâ€¦ Any assistance would be greatly appreciated.
Hi there ğŸ™‚ My best suggestion is to ask this question on the official Cutter telegram\IRC chat.
Thanks I will do that!
Your email address will not be published.
Required fields are marked *
 Notify me of follow-up comments by email.
 Notify me of new posts by email.
