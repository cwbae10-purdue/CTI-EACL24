Previously, in the first part of this article, we used Cutter, a GUI for radare2, to statically analyze APT33â€™s Dropshot malware.
We also used radare2â€™s Python scripting capabilities in order to decrypt encrypted strings in Dropshot.
If you didnâ€™t read the first part yet, I suggest you do it now.
Todayâ€™s article will be shorter, now that we are familiar with cutter and r2pipe, we can quickly analyze another interesting component of Dropshot â€” an encrypted resource that includes Dropshotâ€™s actual payload.
SoÂ without further ado, letâ€™s start.
Cutter is available for all platforms (Linux, OS X, Windows).
You can download the latest releaseÂ here.
If you are using Linux, the fastest way to use Cutter is to use the AppImage file.
If you want to use the newest version available, with new features and bug fixes, you should build Cutter from source by yourself.
It isnâ€™t a complicated task and it is the version I use.
First, you must clone the repository:
If any of those do not work, check the more detailed instruction pageÂ here
As in the last part, weâ€™ll analyze Dropshot, which is also known by the name StoneDrill.
It is a wiper malware associated with the APT33 group which targeted mostly organizations in Saudi Arabia.
Dropshot is a sophisticated malware sample, that employed advanced anti-emulation techniques and has a lot of interesting functionalities.
The malware is most likely related to the infamous Shamoon malware.
Dropshot was analyzed thoroughly by KasperskyÂ and later on by FireEye.
In this article, weâ€™ll focus on decrypting the encrypted resource of Dropshot which contains the actual payload of the malware.
The Dropshot sample can be downloaded from hereÂ (password: infected).
I suggest you star (â˜…) the repository to get updates on more radare2 tutorialsÂ ğŸ™‚
Please, be careful when using this sample.
It is a real malware, and more than that, a wiper!
Since weâ€™ll analyze Dropshot statically, you can use a Linux machine, as I did.
Assuming you went through the first part of the article, you are already familiar with Cutter and r2pipe.
Moreover, you should already have a basic clue of how Dropshot behaves.
Open theÂ Dropshot sample in Cutter, execute in Jupyter the r2pipe script we wrote and seek to the `main` function using the â€œFunctionsâ€ widget or the upper search bar.
A function we analyzed in the previous article | Click to enlarge
The role of the main()Â function in a program shouldnâ€™t be new to you since it is one of the fundamentalÂ concepts of programming.
Using the Graph mode, weâ€™llÂ go thorugh mainâ€˜s flow in order to find our target â€“ the resource decryption routine.
We can see that a function at 0x403b30Â is being called at the first block of main.
Double-clickingÂ this line will take us to the graph of fcn.00403b30, a rather big function.
Going through this function, weâ€™ll see some non-sense Windows API calls with invalid arguments.
When describing Dropshot, I said that it uses anti-emulation heavily â€“ this function, for example, performs anti-emulation.
Anti-emulation techniques are used to fool the emulators of anti-malware products.
The emulators are one of the most important components of many security products.
Among others, they are used to analyze the behavior of malware, unpack samples and to analyze shellcode.
It is doing this by emulating the programâ€™s workflow by mimicking the target architectureâ€™s instruction set, as well as the running environment, and dozens or even hundreds of popular API functions.
All this is done in order to make a malware â€˜thinkâ€™ it has been executed in a real environment by a victim user.
The emulator engine is mimicking the API or the system calls that are offered by the actual operating systems.
Usually, it will implement popular API functions from libraries such asÂ user32.dll,Â kernel32.dll, andÂ ntdll.dll.
Most of the times this will be a dummy implementation where the fake functions wonâ€™t really do anything except returning a successful return value.
By using different anti-emulation techniques, malware authors are trying to fool a generic or even a specific emulator.
The most common technique, which is also implemented in Dropshotâ€™sÂ fcn.00403b30, is the use of uncommon or undocumented API calls.
This technique can beÂ improved by using incorrect arguments (like NULL) to a certain API function which should cause an Access Violation exception in a real environment.
In our case, Dropshot is calling some esoteric functions as well as passing non-sense arguments to different API functions.
More information about emulation and anti-emulation mechanisms are available in the following, highly recommended, book:Â The Antivirus Hackerâ€™s Handbook
Now that weÂ know all this, we can rename this function from fcn.00403b30Â toÂ a more meaningful name.
I used â€œAntiEmulationâ€ but you can choose whatever name you want, as long as it is meaningful to you.
Clicking the call instruction and then pressing Shift+N will open the Rename dialog box.
Right-clicking the row and choosing â€œRenameâ€ will do the job as well.
After mainÂ is calling to the AntiEmulation function, we are facing a branch.
Hereâ€™s the assembly, copied from Cutterâ€™s Disassembly widget:
As you can see, the code would never branch to 0x40429dÂ since this test eax, eaxÂ followed by je ...Â is basically checking whether eaxÂ equals 0.
One instruction before, the program moved the value 1 to eax, thus 0x40429d would be The Road Not Taken.
Weâ€™ll skip the next block which is responsible for creating temporary files and take a look at the block starting atÂ 0x4041f9.
In this block, weâ€™ll see that Dropshot is creating a modeless Dialog box using CreateDialogParamAÂ with the following parameters:Â CreateDialogParamA(0, 0x410, 0, DialogFunc, 0);.
The DialogPrc callback which is passed toÂ CreateDialogParamA is recognized by radare2 and shown by Cutter as fcn.DialogFunc.
This function contains the main logic of the dropper and this is the function that weâ€™ll focus on.
Later in this block, ShowWindowÂ is being called in order to â€œshowâ€ the window.
Obviously, this is a dummy window which would never be shown since the malware author doesnâ€™t want any artifact to be shown to the victim.
ShowWindow will trigger the execution of fcn.DialogFunc.
Double-clikcing onÂ fcn.DialogFuncÂ will take us to the function itself.
We can see that it is performing several comparisons for the messages it receives and then is calling to a very interesting function fcn.00403240.
The first block of fcn.00403240Â is pretty straightforward.
DropshotÂ is getting a handle to itself using GetModuleHandleA.
Then, by using FindResourceA, it is locating a resource with a dummy type 0x67 (Decimal: 111) and a name 0x6e (Decimal: 110).
Finally, it is loading a resource with this name using LoadResource.
Using Cutter, we can see the content of this resource.
Simply go to the Resources widget and locate the resource with the name â€œ110â€.
As you can see in the screenshot above, the size of the resource is 28 Bytes and its Lang is Farsi which might hint us about the threat actor behind Dropshot.
Double-clicking the resource will take us to the resourceâ€™s address.
Letâ€™s click on the Hexdump widget to see its data.
In the hexdump we can see that this resource contains the following bytes: 01 00 00 00 00 00 00 00 01 00 00 00 00 00 00 00 01 00 00 00 01 00 00 00 00 00 00 00.
Those of you who are familiar with radare2 may use the Console widget in the bottom left to do this quickly with px:
This resource will be used later but we wonâ€™t be getting into it since it is out of the scope of this post.
After loading the resource, in the next block we can see the start of a loop:
This loop is checking if local_2chÂ equals to 0x270f (Decimal: 9999) and if yes it exits from the loop.
Inside this loop, there will be another loop of 999 iterations.
So basically, this is how this nested loop looks like:
This is just another anti-emulation\analysis technique which is basically doing nothing.
This is another example of the heavy use of anti-emulation by Dropshot.
After this loop, the right branch is taken and this is an interesting one.
At first, VirutalAllocÂ in the size of 512 bytes is being called.
Next, fcn.00401560Â is called with 3 arguments.
Letâ€™s enter this function and see whatâ€™s in there:
We can see the 2 functions we analyzed in the previous article: decryption_functionÂ and load_ntdll_or_kernel32.
Also, you can notice the comment onÂ call decryption_functionÂ which is telling us that the decrypted string is GetModuleFileNameW.
This comment is the result of the r2pipe script we wrote.
In this function,Â GetModuleFileNameW will be decrypted, then Kernel32.dll will be loaded and GetProcAddressÂ will be called to get the address ofÂ GetModuleFileNameWÂ and then it will move it to [0x41dc04].
Later in this function,Â [0x41dc04] will be called.
Basically, this function is wrapper aroundÂ GetModuleFileNameW, something which is common in Dropshotâ€™s code.
Letâ€™s rename this function to w_GetModuleFileNameW where â€œw_â€ stands for â€œwrapperâ€.
Of course, you can choose whatever naming convention you prefer.
Usually, along the program, this function is used to fill an allocated buffer with zeroes.
This is quite strange to me, since VirtualAlloc is already â€œinitializes the memory it allocates to zeroâ€.
Letâ€™s name this function to memset_Â using Shift+N or via right click and move on.
Right after the program is zeroing-out the allocated memory, we see a call to another function â€“Â fcn.00401c90.
We can see 3 arguments which are being passed to it, 0x14, 0x66, and 0x68.
Since sometimes we prefer to see decimal numbers and not hex, letâ€™s use another useful trick of Cutter.
Right-click on any of these hex numbers and choose â€œSet Immediate Base toâ€¦â€ and then select â€œDecimalâ€.
Now we can see that the values which are being passed to fcn.00401c90Â are 20, 102 and 104.
20 was the size of the buffer that was just allocated.
102 and 104 remindÂ us the Resource name and type that used before (110 and 111).
Are we dealing with resources here?
Moving to the Resources widget again, we can see that thereâ€™s indeed a resource named â€œ102â€ which â€œ104â€ is its type.
And yes, it is 19B long, close enough ğŸ˜‰
fcn.00401c90is one of the key functions involved in the dropper functionality of Dropshot.
The thing is, that this function is rather big and quite complicated when you donâ€™t know how to look at it.
Weâ€™ll get back to it in one minute but before that, I want to show you an approach I use while reverse engineering some pieces of code and while facing a chain of calls to functions which are probably related to each other.
First, we saw that 20 bytes were allocated byÂ VirtualAlloc and the pointer to the allocated memory was moved to [local_ch].
Right after that, memset_Â was called in order to zero-out 20 bytes at[local_ch], i.e to zero-out the allocated buffer.
Immediately after, fcn.00401c90Â was called and 3 arguments were passed to it â€“ 104, 102 and our beloved 20.
We know that 102 is a name of a resource and its size is almost 20.
We donâ€™t know yet what this function is doing but we know that its return value(eax) is being passed along with 2 more arguments to another function, fcn.00401a80.
The other arguments are, you guessed right, 20 and the allocated buffer.
A quick look at fcn.00401a80, which is a really tiny function, will reveal us that this function is copying a buffer to the allocated memory.
This function is quite similar to memcpy so weâ€™ll renameÂ it toÂ memcpy_.
So now we can do an educated guess and say thatÂ fcn.00401c90 is reading a resource to a buffer and returns a pointer to it.
Using this approach, we can understand (or at least guess) a complicated function without even analyzing it.
Just by looking at a programs chain of function calls, we can build the puzzle and save us important time.
That said, weâ€™ll still give this function a quick analysis because we want to be sure that we guessed right, and more importantly â€” because this is an interesting function.
The next part is where things are getting more complicated.
Weâ€™ll start by goingÂ over fcn.00401c90Â pretty fast so try to follow.
Also, you may want to make sure you fasten yourself since we are going on a rollercoaster ride through the PE structure.
Take a look at the first block of this function.
Youâ€™ll see one callÂ andÂ a lot of mov, addÂ and calculation of offsets.
This is how a typical PE parsing looks like.
At first, a handle to the current process is received using GetModuleHandleW.
Then, the handle (eax) is being moved to a variety of local variables.
First, it is being moved to [local_34h]Â at 0x00401ca5.
Then you can see eaxÂ moved to [local_20h]Â which is later being moved to [local_24h]Â using ecx.
So basically we have a bunch of local variables that currently hold the handleÂ hmodule.
We can rename all three variables to [hmodule_x]Â so itâ€™ll be easier to keep track of all the reference to hmodule.
To rename flags you can use the Console widget and just execute afvn old_name new_name.
For example, I executed: afvn local_34h hmodule_1; afvn local_20h hmodule_2;Â afvn local_24h hmodule_3.
GetModuleHandleÂ returns a handle to a mapped module, this basically means that our hmodules point to our binaryâ€™s base address.
In line 0x00401cb4Â we can see that [hmodule_3]Â is moved to edx, then the value at [edx + 0x3c]Â is being moved to eax and [hmodule_3] isÂ added to it at 0x00401cba.
Finally, eaxÂ is moved to [local_38h].
To put it simply, we can use the following pseudo-code:
So whatâ€™s in this address?
Use your favorite binary structure viewer to find out.
In this example, Iâ€™ll use PEview but you can use any other program you prefer â€“ including the binary structure parsing feature of radare2, if youâ€™re already a radare2 pro (see pf?
Open Dropshot in PEview and inspect the DOS Header:
As you can see, in offset 0x3cÂ there is a pointer (0x108) to the offset to the new EXE Header which is basically the IMAGE_NT_HEADER.
So [local_38h]Â holds the address of the NT Header.
Letâ€™s rename it to NT_HEADER and move on.
At address 0x00401cc0Â we can see that NT_HEADER is moved to ecxÂ and then the program is adding 0x18 toÂ ecx.
Last, the value in ecxÂ is moved to [local_3ch].
Just as before, letâ€™s open again our PE parser and check what is in NT_HEADER + 0x18.
Adding 0x18 to 0x108 will give us 0x120.
Letâ€™s see what is in this offset:
0x120 is the offset of the IMAGE_OPTIONAL_HEADER as can be seen in the image above.
Letâ€™s rename local_3chÂ to OPTIONAL_HEADER.
To cut aÂ long story short, Dropshot is then parsing the IMAGE_DATA_DIRECTORY structure (OPTIONAL_HEADER + 0x60), the RESOURCE_TABLE, and last it iterates through the different resources and compares theÂ resource type and the resource name to the functionâ€™s arguments.
Finally, it uses memcpy_Â to copy the content of the required resource to a variable and returns this variable.
Now we can rename the function to get_resourceÂ and the arguments to the corresponding meaning of them by executing afvn arg_8h arg_rsrc_type; afvn arg_ch arg_rsrc_name; afvn arg_10h arg_dwsize.
Now that we are sure about what this function does, we can see where else it is referenced.
Right-click on the function and choosing â€œShow X-Refsâ€ (or simply pressing â€˜xâ€™) will take us to the X-Refs window.
We can see that get_resourceÂ is being called from two locations.
One (0x0040336d) is already familiar to us, it is called to get resource â€œ102â€.
The second call (at 0x00403439), a few instructions later, is new to us â€” it is called to get the content of another resource, named â€œ101â€ (0x65).
Remember the screenshot of the Resources widget from before?
We can see there the resource named â€œ101â€.
What makes â€œ101â€ so interesting is that it isÂ much bigger than the other â€” its size is 69.6 KB!
By going to the Resources widget and double-clicking â€œ101â€ will take us to the resourceâ€™s offset in the binary.
In the Hexdump widget, we can see that the content of this resource makes no sense and has a really high entropy (7.8 out of the maximum 8):
This data is compressed/encrypted somehow so we need to decrypt it.
Letâ€™s continue our analysis to find out how.
In order to decrypt the resource, we should follow the programâ€™s flow to see how and where the payload is being used.
Right after get_resourceÂ is being called with â€œ101â€ and â€œ103â€, the resource is copied to [local_20h] using memcpy_ (at 0x00403446).
The compressed buffer is then passed to fcn.00401e70Â which is a function that performs dummy math calculations on the resourceâ€™s data.
Probably another Anti-Emulation technique or simply a way to waste our time.
Iâ€™ll rename it to dummy_math.
Next, compressed_payload is being passed to fcn.00401ef0Â along with another buffer [local_54h].
The analysis of this function is out of the scope of this article but this function is responsible to decompress a buffer using zlib and put the decompressed buffer in [local_54h].
You can see, for example, that fcn.00401ef0Â is calling to fcn.004072f0Â which contains strings like â€œunknown compression methodâ€ and â€œinvalid window sizeâ€ which can be found in the file inflate.c in the zlib repository.
I renamedÂ fcn.00401ef0Â to zlib_decompressÂ and local_54hÂ to decompressed_payload.
Iâ€™ll tell you now that simply a decompression of the buffer isnâ€™t enough since thereâ€™s still another simple decryption to do.
Straight after the decompressing, we can see more of the Anti-Emulation which we are already familiar with.
Finally, our decompressed buffer is being passed to fcn.00402620.
This function is responsible for the last decryption of the resource and then it performs a notorious technique known as â€œProcess Hollowingâ€ or â€œRunPEâ€ in order to execute the decrypted payload.
So howÂ fcn.00402620Â decrypts the decompressed payload?
Simply, it uses ror 3Â to rotate-right each byte in the decompressed buffer.
3 stands for the number of bits to rotate.
The rest of this function is interesting as well but it has nothing to do with decrypting the resource so Iâ€™ll leave it to you.
To sum things up, and before we adding the logic for the resource decryption inside the script we wrote in the previous article â€“ letâ€™s sketch how the decryption function should look like.
It should be something like this:
Scripting radare2 is really easy thanks toÂ r2pipe.
It is the best programming interface for radare2.
The r2pipe APIs are based on a single r2 primitive found behindÂ r_core_cmd_str()Â which is a function that accepts a string parameter describing the r2 command to run and returns a string with the result.
r2pipe supports many programming languages includingÂ Python,Â NodeJS,Â Rust,Â C, and others.
Luckily, Cutter is coming with the python bindings ofÂ r2pipeÂ integrated into its Jupyter component.
Weâ€™ll write an r2pipe script that will do the following:
Just as in the previous part, letâ€™s go to the Jupyter widget and open the script we wrote when decrypted the strings (part1).
The first thing to do is to read the content of the encrypted and compressed resource to a file:
iRÂ was used to get the list of resources and their offsets in the file.
Next, we iterate through the different resources untill we find a resource named â€œ101â€.
Last, using pxÂ we are reading the resourceâ€™s bytes into a varibale.
We appended jÂ to the commands in order to get their output as JSON.
Next, we want to decompress the buffer using zlib.
Python is coming with â€œzlibâ€ library by default which is great news for us.
Add import zlibÂ to the top of the script and use this code to decompress the buffer:
Now that our buffer is decompressed in decompressed_data, all we left to do is to perform right rotation on the data and save it to a file.
Define the following ror lambda:
And use it in your code like this:
Last, save it to a file:
Now letâ€™s combine the script from the previous article to the one we created now and test it in Jupyter.
The combined script should first decode the encrypted scripts, and then it should decrypt the resource and save it to the disk.
The final script can be found here.
Copy it and paste it into your Jupyter notebook.
You can also execute your version of the code to see if you got it right by yourself.
Seems like our script was executed successfully and â€œSaved the PE to ./decrypted_rsrc.binâ€.
The last thing we want to doÂ is to openÂ decrypted_rsrc.bin in a new instance of Cutter in order to verify that this is indeed a PE file and that we didnâ€™t corrupt the file in some way.
Cutter recognized the file as PE and seems like the code is correctly interpreted.
This binary we just decrypted and saved is the Wiper module of Dropshot â€“ a quite interesting piece of malware on its own.
This module, just as its dropper, is using heavy anti-emulation and similar technique to decrypt its strings.
You can give it a try and analyze it on your own using Cutter, radare2, and r2pipe.
Here comes to an end the second and the last part of this series about decrypting Dropshot with Cutter and r2pipe.
We got familiar with Cutter, radare2 GUI, and wrote a decryption script in r2pipeâ€™s Python binding.
We also analyzed some components of APT33â€™s Dropshot, an advanced malware.
As always, please postÂ comments to this post or message meÂ privatelyÂ if something is wrong, not accurate, needs further explanation or you simply donâ€™t get it.
Donâ€™t hesitate to share your thoughts with me.
Subscribe on the left if you want to get the next articles straight in your inbox.
Your email address will not be published.
Required fields are marked *
 Notify me of follow-up comments by email.
 Notify me of new posts by email.
