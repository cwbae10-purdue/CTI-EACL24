Sednit is back – this time with two more zero-day exploits embedded in a phishing email titled Trump’s_Attack_on_Syria_English.docx.
The Sednit group, also known as APT28, Fancy Bear and Sofacy, is a group of attackers operating since at least 2004 and whose main objective is to steal confidential information from specific targets.
In October 2016, ESET published an extensive analysis of Sednit’s arsenal and tactics in a whitepaper titled En Route with Sednit.
Last month, Sednit came in the light again, allegedly interfering with the French elections and more precisely going after the frontrunner Emmanuel Macron.
In the same time period, a phishing email containing an attachment named Trump’s_Attack_on_Syria_English.docx caught our attention.
Analysis of the document revealed its end goal: dropping Sednit’s well-known reconnaissance tool, Seduploader.
To achieve this, Sednit used two zero-day exploits: one for a Remote Code Execution vulnerability in Microsoft Word (CVE-2017-0262) and one for a Local Privilege Escalation in Windows (CVE-2017-0263).
ESET reported both vulnerabilities to Microsoft, who today released patches during the regular Patch Tuesday schedule.
This blogpost describes the attack itself and the vulnerabilities used to infect its potential targets.
The graphic below shows that this specific attack is totally in line with Sednit’s usual attack methods: the use of a spearphishing email containing a malicious attachment to install a known first-stage payload.
This time, the phishing email was related to Trump’s attack on Syria.
The infected attachment is a decoy document containing a verbatim copy of an article titled “Trump’s Attack on Syria: Wrong for so Many Reasons” published on April 12, 2017 in The California Courier:
This is where the attack becomes interesting.
The decoy document contains two exploits allowing the installation of Seduploader.
See the schema below for an overview.
These two exploits can be added to the list of zero-day vulnerabilities used by Sednit over the last 2 years, as shown in this timeline:
Once opened, the decoy document first triggers CVE-2017-0262, a vulnerability in the EPS filter in Microsoft Office.
In this case, the malicious EPS file is called image1.eps within the .docx file:
The EPS exploit file is obfuscated by a simple XOR.
EPS provides the functionality to XOR variables and evaluate source (exec).
The key used here is 0xc45d6491 on a big hex-encoded string and exec is called on the decrypted buffer.
Once decrypted, the exploit looks very similar to the one which was well documented by FireEye in 2015.
The vulnerability used at the time was CVE-2015-2545.
The main difference is highlighted in the following block, which is how it performs the memory corruption with the forall instruction.
Once code execution is obtained, it loads a shellcode that retrieves some undocumented Windows APIs such as NtAllocateVirtualMemory, NtFreeVirtualMemory and ZwProtectVirtualMemory
After more decryption, the Seduploader Dropper is then loaded and executed.
Note that all this execution happens within the WINWORD.EXE process running with the current user’s privileges.
Seduploader is made up of two distinct components: a dropper and a persistent payload (see page 27 of our En Route with Sednit whitepaper).
While the dropper used in this attack has evolved since the last version we analyzed, its end goal remains the same: to deliver the Seduploader Payload.
This new version of the dropper now contains code to integrate the LPE exploit for CVE-2017-2063.
The detailed analysis of this vulnerability can be found in the next section of the blog; for now, we will focus on Seduploader.
First, the new code in the dropper checks if the process is running on a 32-bit or 64-bit version of Windows.
Depending of the result, the correct exploit version will be loaded in memory.
Once the exploit is successfully executed, Seduploader Dropper will reload itself in WINWORD’s memory space and call CreateRemoteThread with the address of the UpLoader entry point, which will execute the code in charge of installing the Seduploader Payload.
This code will run with System privileges, thanks to the exploit.
Seduploader Payload is a downloader used by Sednit’s operators as reconnaissance malware and is composed of two parts.
The first is responsible for injecting the second part in the proper process, depending on whether it is loaded in the WINWORD.EXE process or not.
The second part is the downloader itself.
If Seduploader is running in WINWORD.EXE, its first part will create a mutex named flPGdvyhPykxGvhDOAZnU and open a handle to the current process.
That handle will be used to allocate memory and write in it the code of the second part of the Payload component, which will then be executed by a call to CreateRemoteThread.
Otherwise, if it is not running in WINWORD.EXE, Seduploader will use CreateThread to launch its second part.
The downloader contains the usual Seduploader functions and strings encryption algorithm.
However, it contains a certain number of changes that we describe below.
First, the hashing algorithm used to identify DLL names and API functions to resolve was replaced by a new one.
The attentive readers of our whitepaper will recall that the old hashing algorithm was strongly inspired from code found in Carberp.
Well, the new algorithm was also not created from scratch: this time, Sednit used code very similar to PowerSniff.
Next, a new img tag was added in Seduploader’s report message.
This tag allows the exfiltration of screenshots:
As usual, Sednit operators did not reinvent the wheel.
We found some similarities between their implementation of the screenshot function and code available on stackoverflow.
Instead of using GetForegroundWindow to retrieve a handle on the foreground window in which the user is currently working, Sednit chose to use keybd_event to send a “Print screen” keystroke and then retrieve the image from the clipboard.
The image is then base64-encoded and added to the report, whose structure now looks like this:
* result of “import win32api;print hex(win32api.GetVolumeInformation(“C:\\”)[1])”
** content of HKLM\SYSTEM\CurrentControlSet\Services\Disk\Enum
*** toggled if SEDUPLOADER uses injection into a browser to connect to Internet
Screenshotting was used before by Sednit.
In the past, the feature was built in a separate, standalone tool often invoked by Xtunnel at a later infection stage (see page 77 of our whitepaper), but it is now built in Seduploader for use at the reconnaissance phase.
Finally, on the config side, two new functions were added: shell and LoadLib.
The shell config allows the attacker to execute arbitrary code directly in-memory.
The LoadLib is a bit field that allows running an arbitrary DLL by calling rundll32.exe
As mentioned before, in order to deploy Seduploader Payload, Seduploader Dropper gains System privileges by exploiting CVE-2017-0263, an LPE vulnerability.
In this section, we will describe how this vulnerability is exploited by Sednit.
First, even though the vulnerability affects Windows 7 and above (see at the end of this post for the full list of affected platforms), the exploit is designed to avoid running on Windows version 8.1 and above.
Since the exploit can target both 32-bit and 64-bit platforms, it will first determine if the process is running under WOW64.
The exploit will allocate multiple pages, until it reaches a high address (0x02010000).
It will then build the following structure:
Then, it will retrieve the address of HMValidateHandle.
This function allows the attacker to leak the kernel address of a tagWND object.
Here is an overview of how the rest of the exploit works:
The exploit will create 256 random window classes and their associated windows.
Each window will have 512 bytes of extra memory.
This extra memory is contiguous to the tagWND object in the kernel space.
After the first created window, i.e.
in the extra memory, the exploit will build a fake object containing mostly only its own address for later use, as shown in the picture:
When all the windows are created, the exploit will allocate 2 additional windows.
The purpose of first one is to be executed in a kernel thread: let’s call this window KernelWnd, and the other one will mainly receive all the necessary messages needed for the exploit to complete; let’s call this window TargetWindow.
Then, the exploit associates this procedure with the newly allocated object, KernelWnd.
// …
TargetWindow = CreateWindowExW(0x80088u, MainWindowClass, 0, WS_VISIBLE, 0, 0, 1, 1, 0, 0, hModuleSelf, 0);
KernelWnd = CreateWindowExW(0, MainWindowClass, 0, 0, 0, 0, 1, 1, 0, 0, hModuleSelf, 0);
// …
SetWindowLongW(KernelWnd, GWL_WNDPROC, (LONG)Payload_0->WndProc);
Let’s add some context around the behavior of the win32k component.
Every time you create a new window through CreateWindowExW, the driver will allocate a new tagWND object in the kernel.
The object can be described like this (some fields are removed for clarity’s sake):
As you can see, the tagWND->lpfnWindowProc contains the address of the procedure associated with this window.
The driver usually lowers its privileges in order to execute this procedure in the user’s context.
This behavior is controlled by the bit tagWND->bServerSideProc.
If this bit is set, then the procedure will be run with elevated privileges, i.e in the kernel.
The exploit works by flipping the tagWND->bServerSideProc bit.
All the attacker needs to do is to find a way of flipping that bit.
During the destruction of the menus, the hook set up before will check if the class of the object is SysShadow as shown on the next code block.
If that’s the case, it will replace the associated procedure with its own.
In this procedure, we can see that the exploit looks for the WM_NCDESTROY message.
If the requirements are met, it will build a malicious tagPOPUPMENU object which is described by the following pseudocode:
Note that the address used to build this object is within the extra memory allocated at the end of our first tagWND.
Then, the exploit calls NtUserMNDragLeave, in order to flip the bServerSideProc bit of our KernelWnd object.
To do so, the function will retrieve a tagMENUSTATE object using the structure tagTHREADINFO.
The tagMENUSTATE object contains the address of the menu object being destroyed (tagMENUSTATE->pGlobalPopupMenu).
As you can see, the tagPOPUPMENU is the malicious object we crafted in user space before calling NtUserMNDragLeave.
Looking at the fields in the malicious tagPOPUPMENU, we can see that they all points in the extra memory except one, which points into our KernelWnd object.
From here, the execution will reach the function MNFreePopup, which takes a pointer to a tagPOPUPMENU object.
Eventually this function will call HMAssignmentUnlock, passing the fields spwndNextPopup and spwndPrevPopup as argument:
After the execution of the syscall, our tagWND structure associated with our KernelWnd looks like this:
The exploit just needs to send the right message in order to trigger the execution of our procedure in kernel mode.
Finally, the window procedure running with elevated privileges will steal the SYSTEM token and add it to the calling process.
After successfully running the exploit, FLTLDR.EXE should run with SYSTEM privileges, and will install Seduploader’s payload
This campaign shows us that Sednit has not ceased its activities.
They still keep their old habits: using known attack methods, reusing code from other malware or public websites, and making small mistakes such as typos in Seduploader’s configuration (shel instead of shell).
Also usual is the fact that they once again improved their toolset, this time adding some built-in features such as the screenshotter and integrating two new zero-day exploits into their arsenal.
Microsoft advises all customers to follow the guidance in security advisory ADV170005 as a defense-in-depth measure against EPS filter vulnerabilities.
Also available on ESET’s Github.
